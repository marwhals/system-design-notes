%\part{Domain Driven Design}
%TODO hmmmm consider where to place this in the document -------
%TODO hmmmm consider which parts to skim.........

\chapter{Microservices Architecture}

\section{Business and Digital Transformation}
Business transformation is an umbrella term that is used for referring to fundamental changes in how an organisation conducts its business.
See examples......

\subsection{Why do businesses need to transform}
- Environmental changes - new regulations may force the organisation to change how they do business.
- Competitive pressure - think of an organisation that is dealing with a competitor that is rolling out innovative products at a very rapid pace/

What is the choice for these organisations?
They must transform.
They have to think of new products.
They have to think about the speed at which they can roll out these new products.

- New opportunities - Organisations may have to transform themselves to integrate with new technology.
This often requires serious transformation initiatives.
- Customer demands - expectations are continuously changing in order to maintain and expand their customer base.
Organisations need to adjust their business to meet their customers demands and expectations.
Businesses that ignore their customers expectations tend to loose out to the competitors.

\subsection{Digital Transformation}
The process of using digital technologies to meet the needs of transformed business processes and to create innovative customer engagement mechanisms.
The relationship between digital transformation and business transformation is that the digital transformation supports the business transformation initiatives (ahem)
%    TODO insert examples ---- potentially with critique
The value in this is that it allows for organisations to change at a very rapid pace.
Businesses that fail to transform fail to survive.
Netflix vs Blockbuster

Transformation is not a one time initiative.
Businesses need to change on a continuous basis and this requires rapid changes to their systems and applications.
Organisations must keep up with the pace of new and evolving technologies.

\subsection{Common problems}
A common challenge that businesses face in their transformation journey is that the old ways of building software hinders or makes it difficult for organisations to transform.
It is slow to build software using the older technologies and architectural paradigms.
Older technologies and older ways of building applications to integrate with newer digital technologies
This is where microservices architecture can help.
Microservices architecture addresses these challenges and helps the organisations move at a faster pace to achieve their transformational objectives.
Transformation is about rapid changes, and in the case of microservices, changes are isolated to a set of microservices.
Changes to a small microservices will be much faster than changes to a monolith where there are a lot of interdependencies between multiple modules realising the different business funtionalities.

\subsection{Summary}
Organisations need to continuously transform.
The requires IT systems to change at a rapid pace.
There is a need for rapid adoption of new digital technologies and speed to market is key.
Microservices architecture helps the organisations meet these requirements from IT perspective.

\section{A Business Perspective of Microservices}

\section{A Technical Perspective of Microservices}

\section{Adoption of Microservices Architecture}

\chapter{Introduction to Domain Driven Design}

\section{Domain, Sub-Domain and Domain Experts}
A domain is defined as a sphere of knowledge, influence or activity.
The business perspective - a domain represents the field or industry in which the business operates.
The software perspective - domain may be though of as the representation of the problem space for that software. The domain is made up of multiple sub domains.

For large and complex domains, it is virtually impossible for a domain expert of know everything about the domain (challenge accepted :D).
As a result, there are multiple subject matter experts or domain expert within a domain, mostly aligned with the sub domains in the bigger picture.

Useful questions:
- What domain do you operate in? Think business domain not technology domain.
- What are the sub domains within the domain that you operate in?
- List out the domain experts that you work with.

Summary
- Domain is defined as a sphere of knowledge, influence or activity.
- Domains are made up of multiple sub domains.
    - It is not possible for a single expert to have a through knowledge of all the sub domains in a complex large domains (MVK?)
    - As a result multiple domain experts are needed to support business functions.
    - Mostly, these domain experts are aligned with the sub domains within the larger domain

\section{Conceptual Models, Architural Styles}
Conceptual models are defined as a representation of a system made from a composition of concepts. Key idea here is concepts.
I.e that focus is not on the physical parameters of the system.

The focus here is on the critical components that make up the system.
This information is not sufficient for the engineer in the factories to be able to build the car.

Whats the purpose?
Multiple benefits to of starting with conceptual models.
The first one is that it enhances the understanding of the designers.
As the designers put together the concept and think through it, they may find flaws in the design or the may find opportunities for improvement.
---> A good conceptual model will lead to a better product.
Second one is that it makes it easy to convey the ideas behind the concept to the stakeholders.
Third one is that conceptual models provide a point of reference to create detailed specifications.
This model contains some information about the physical aspects of the end product.
This information, combined with the models layout can act as the starting point for the designers.

The fourth one is that conceptual models provide documentation for future reference.
The first thing they do is identify the core concepts that need to be put together to design the final product.
They come up with the common terminology for the domain concepts used in the model.
They identify the different parts of the system.

Also they will identify the different parts of the overall product of the system.
Next, the designer identifies and documents the relationship between the various domain concepts, and they also identify the critical or the foundational parameters for these concepts as well as the relationships in the banking domain.

Architectural model - the visualisation of the system represented by the model.

A more formal definition of the architectural model or architecture is that is is a strcutured representation of a solution that meets the requirements in the problem space.
It is a high level abstraction of parts of the end solutions that presents a view or a perspective on how the requried payments will be met and it assists in answering the questions posed by different stakeholders.

What is the difference between architectural model or architecture and design?

The difference is in the level of details and focus.

Architecture is mostly high level.
Provides a skeleton for the end product and the focus is more long term concepts. Components that may not change as freqeuently or never in the lifetime of the product.
The design is relatively detailed and the focus is on implementation.
This is relative. Design can also be high level but they are relatively detailed compared ot the convetional or traditional architecture models.

Summary
1 - Conceptual models - a set of concepts and their relationships
2 - Architectural models are a structured representation of solution that meets the requirements from the problem space. Does not have any implementation details
3 - Whereas design is a structured representation of a solution that has some level of implementation details in it.

\section{Modelling Techniques and Architectural Styles}
Author opinion
- Three guiding principles
- Think about the purpose of the model and the audience for whom the model is being created for. Think about the prespective and the viewpoints of the audience.
    - The idea is to think about their interests and their concerns.
    - Will the model that I'm creating address their concerns and answer their questions?
- Third one is level of details. How detailed should my model be so that it provides most value to the target audience.

Many techniques for creating these models (hmmmmm)

Four plus one architectural view model describes the architecture from the viewpoints of multiple stakeholders.
Central to this technique is the idea of scenarios of use cases. Think of these as requirements.
These scenarios are used as guide for creating multiple views and these scenarios are also used for validating architecture.

Logical view focuses on the functionality or the capabilities exposed by the system to the end user.
The process view, as the name suggests explains the processes in the system and how these processes interact with each other.
The development view illustrates a system from a programmers perspective and is concerned with software management. This view is also known as the implementation view.
The last one is the physical view that depicts the system form the point of view of the engineers.
It is concerned with the topology of software components on the physical layer as well as the phyiscal connetion between these components.

%TODO add four plus one diagram

Why call it four plus one?
The reasons is there are four views and plus on is for the scenarios.
A large software project involves multiple stakeholders.
They may be tens or even hundreds of stakeholders involved in the project.
These stakeholders have different set of interests and concerns.

Business Exec - Their interest is in understanding the value that the system will provide to the end user and how that end user value will translate into value for the business.
Business experts - important that the business implements the right set of processes and these processes are accurate. Their interests will be in the process.
Developers - they are concerned with the implementation of the system.
They are concerned about the deployments and the management of the software.
As a result their interest is in the development view.
Network engineer - are not concerned with he development view or the logical view or the process view.
They would like to understand how the various servers that will host the applications or the components will talk to each other over the network.
Architecture view - finally, the architect is responsible for creating these views and ensuring that these views rae providing the most value to each of these stakeholders.

This is just a small set of stakeholders.
There may be many more stakeholders playing different roles in the software initiative.

Practice
- List out the stakeholders in your organisation and think about which views will be most appropriate for them.


UML
Created by Object Management Group.
Provides a standard set of diagrams for architectural modelling and these diagrams are created by using a standard set of notations.
Vast subject.
See other resources if required.
Latest version of UML consists of 14 diagrams which can be used to created the 4 + 1 architectural view model.

Author preference.
- Use case diagram for depicting the scenarios for logical views
- Use the state diagram and the class diagram for process view.
- Use sequence diagram and activity diagram for development view
- For development view use the component diagram and package diagram.
- For physical view deployment diagram works out the best.

Software architectural style may be through of as a reusable architectural pattern which may be used as a solution to a commonly occurring problem.
There are multiple architectural styles and these architectural styles are categorised based on the key focus area.
The service orientated architecture and the message bus architecture falls in the category of architectural style that focuses on the communication between components.
The layered architecture and the object orientated architecture and design are the common styles use when the architect is focusing on the structure of the system.
The client server and the three tier architectural styles fall in the category of deployment, wherein the focus is on the deployment of the various components that make up  the system.
The database centric design and the data flow diagrams are styles used where the architect is focusing on the core data within the business domain.


The last architectural design is DDD where the focus on the business domain rather than the technolgoy.

Summary
- Architects create models using different modelling techniques.
- Two such techniques.
The four plus one architectural view model and unified modelling langauge.
- The second may be combined to create very effective architectural models.
- There are multiple architectural styles.
- Each of these follow a set of common principles and they focus on specific aspects of the system.
- Architects may adopt any of these styles depending on their needs and preferences.
- Domain driven design is an architectural style in which the focus in on the business domain.

\section{Domain Models}
Reasons businesses invest in software is to solve business problems.
Business problems may be defined as current or long term challenges and issues that may prevent the business from achieving its goals.
These goals may be short term or they may be long term.
It is important for the architects to understand the business problem.
The architect must understand the domain first and for that the architects create domain models.

%----------------

A domain model is defined as organised structured knowledge of the domain that is relevant for solving a business problem
Important: Organised and structured knowledge.

The domain model consists of multiple parts.
Key concepts are the foundational concepts related ot the domain.
Domain vocabulary - consists of common terms and their definitions used by the stakeholders when they are discussing the problem space wihin that domain.
This ensures that all stakeholders have a common understanding of all the terms used in that domain.

Think of domain entities as domain objects that have a unique identity.
The attributed in the domain objects may change over the lifetime of the object.

In the real world, domain entities have a relationship with other domain entities and the model captures these relationships.

Businesses use defined processes for carrying out the operations and these processes are documented within the domain model by way of workflows and activities.

Important thing to keep in mind is that the domain model captures structured knowledge that is used for solving a business problem.
In fact the domain model may contain additional knowledge by they way of visual depictions or diagrams and textual documentation.

As the creator of the domain model, you are in control of what should go in the domain model to make it as effective as possible.

There are no special tools for creating domain model of visualisations.
May use any typical tool that supports UML modelling for textual documentations.

Stakeholders working on the domain models may decide on the tools that will work out best for them.

Key points
Domain model is organised and structured knowledge about the domain.
The purpose of the domain model is to help with creating a sutions to business problems within that domain.

The five elements.
- Domain vocabulary
- Domain entities
- Relationship between the entities
- Workflows and activities
- Key concepts

\section{Modelling Techniques and Architectural Styles}
Enterprise domain models  - also known as aggregate or unified domain models.

In a complex industry it is hard to find one expert who knows everything.

To get the domain knowledge, the teams must work with these domain experts as this knowledge is mostly not documented anywhere but is in the heads of these domain experts.
Domain knowledge is organised and structured knowledge about the domain and these domain models are created by way of a process referred to as knowledge crunching.

The team receiving the knowledge form the domain expert or experts analyses the received information and knowledge and creates the domain models.

Typically the knowledge crunching process is spearheaded by the technology team that works very closely with the domain experts to create that structured domain knowledge or the domain models.

it is common for the technology team to be led by an experienced technologist. (Some kind of IT lead)

Ideally the IT lead should have some prior experience with domain modelling exercise and it is not required that they are an expert in specific technolgies.

Opinion
- Successful leads have a breadth of knowledge in multiple technologies and they are also open to learning busienss related topics.
Rest of the technology team may be composed of team members with different skill sets and roles.

Idea is that these models could be used by software development teams to build robust well documented systems.
These enterprise modesl were referred to as the unified models or aggregate models.
The idea behind all these are the saem.

Intended software development process looks something like this.
The software development teams will focus on specific areas within the enterprise domain model and then carry out the technical design.
Code and then build the final product.
In theory this sounds good but in reality this process is marred with multiple challenges.

First challenge is the creation of the model itself.
Enterprise models are inherently complex due to the scope and szie and the fact that multiple experts need to be engaged in order to create such models.
The second one is that its hard to keep the models up to data as there is not single owner for the mode and it falls on the IT team to manage the model as well as the software product..hmmmmmm

Unfortunately after a while due to product delivery priorities, models start to fall behind the actual implementations and loses its value.

The third one is that there are linguistic challenges when you try to merge together knowledge about multiple domains into one single model.

Lol - It is very common to see the same business term have different meanings in different sub domains within the organisation.
These linguistic challenges can cause big confusion for the software development team as well as the domain experts.
An important point to note is that these challenges are no applicable to enterprise level domain models but to any domain model that has to deal with complex domains.

Pros of DDD
- Domain driven design approach provides principles and patterns to address the challenges faced with developing complex domain models.

Summary
- Knowledge crunching refers to the process of creating the domain model from the knowledge gathered from the domain experts.
- There are multiple challenges with creating models for complex domains and these challenges are addressed by the domain driven design approach.

\chapter{Domain Driven Design: Strategic Patterns}

\section{Introduction to DDD and Patterns}
Domain driven design is an architectural approach that provides principles and patterns to address challenges faced with developing complex domain models.
Term originates from from Eric Evans, Domain Driven Design book.

Domain driven design emphasises on the fact that the IT project's primary focus should be on the business domain and business logic rather than technology.
Promotes the idea of breaking the unified model into smaller, more manageable models and it suggests the use of iterative process for improving the model to solve a domain problem.

Domain driven design offers two types of patterns.

Strategic patters are used for dividing a complex and large business problem into smaller chunks with well defined boundaries.

Tactical patterns are used for translating the conceptual models to software application and service designs.

The strategic pattern applies across multiple bounded contexts, whereas tactical patterns are applicable only within a bounded context.

The idea is that domain driven design approach leads to smaller, independent domain models that can be built can be built as highly decoupled and independent set of microservices.

\section{Business Subdomain Types}
A business domain is composed of multiple subdomains.
The type depends on the value a subdomain generates for the business.
Having an understanding of the type of subdomains is in a position to assist the business in making the build versus buy decisions for the technology solutions.
Businesses need to perform multiple different functions to operate.
These functions are performed in the purview of subdomains.
Different organisations within the same industry may look at their enterprises in a different way.
From the subdomains perspective, one of the most common reasons is that businesses may not operate in all sub domains in that overarching domain or industry.
Sub domains may be further divided into smaller sub domains and can be seen as sub domain granularity, and it depends on the focus of the business.
Each organisation within an industry, depending on their focus may view their enterprise as composed of different subdomains under the purview fo which htey performn their business operations.
Each subdomain has a different level of complexity associated with it.
There are multiple factors that may be contributing toward the complexity of the sub domain.

\subsection{Reasons for complexity}
The most common reason it the complexity of the business rules itself.
Another reasons is the compliance aspect.
If the sub domain is operating in a highly regulared environment, then that will add complexity to the sub domain.
Complex calculations or complex algorithms may require specialised skills or specialised knowledge to understand the sub domain and that adds to the complexity.
Next one is the processes and the handovers required between the sub domain and other sub domains or even external entities; will also contribute towards the complexity of the sub domains.

Dynamic - idea here is that if the sub domain requires changes to processes, rules, structures or any other aspect, then it will be difficult to manage the knowledge and understanding of the business domain as it is changing with the time .
Depending on the industry, there may be other factors that will contribute toward the complexity of the sub domain.

\subsection{Sub-Domain Categories}
- Sub-domains are categorized into three types based on their complexity and business value it adds.
- Generic, core and supporting.

\subsubsection{Generic Subdomain}
- Known solutions exist for such subdomains
Nothing special about these subdomains
Best practices available
No business advantage in re inventing the wheel

\subsubsection{Core Subdomain}
- Each business within a specific industry operated differently within the core sub domains to gain some kind of advantage over their competition.
- The "secret sauce" for the business resides in the core sub domain and the business is always looking to carryout things differently in these core subdomains to get some kind of competitive advantage, depending on the indusitry and the environment.
- These core subdomains may evolve at a very rapid pace or may have a very high level of dynamicity.
- Organisations are looking to gain some kind of competitive edge by or achieve cost savings which translates into value for the business.

\subsubsection{Supporting subdomain}
Supporting subdomains do not provide any direct business advantage but the core sub domains depend on the supporting sub domains.
Well known practices for supporting subdomains, but solutions may not be readily available.
- Even if the solutions are available, those solutions may need to be customised to meet the needs of the core sub domain.
\textit{Typically the supporting sub domain does not have high levels of complexity in terms of business logic}

\subsection{Identifying sub domains}
Start by looking at the business capabilities in that sub domain.
Are there any known solutions available for the sub domain?
- If yes, then that sub domain is likely to be generic.
Otherwise need to check if that sub domain adds any business value.
- Is there an opportunity for the business to differentiate itself from it competitors by doing things differently within this sub domain.
If no then the next check is to see if the core sub domains depend on this sub domain.
- If yes then it is likely to be a supporting sub domain.
- If no then the the it is a generic sub domain where you may need to build a solution.

If the sub domain has the potential of adding some business value, then next check is to see if the business domain has high complexity.
If the business domain does not have a high level of complexity then it is likely to be a supporting sub domain.
Otherwise it is likely to be a core sub domain.
%    TODO - Add chart

\subsection{Why categorise the sub domains?}
Businesses have limited resources and these resources here are referring to the HR as well as the money put aside for the various initiatives across the enterprise.
Categorisation of the sub domains helps in prioritisation of the various initiatives.
Second reason is return on investments, businesses would like to maximise their return on investments.
- As a result, preferences will be given to the initiatives replated to core sub domains which will lead to the maximisation of the return on investments.
Third reason is that categorisation of the sub domain helps the business in making the buy vs build decisions.
If the sub domain is a generic sub domain, then the business would buy a IT solution rather than build it.
Examples SAP, Workday etc.
If the sub domain is supporting sub domain, then the business may decide to build the solution by way of outsourcing.
Or they may buy a generic solution and customised it to meet the needs of their core domains. E.g salesforce etc.

If they sub domain is categorised as core, then the business will use its best teams and best talent to build the solution in this sub domain.
The generic sub domain has readily available solutions that the business can buy.
The core subdomain is the sub domain where the business has the opportunity to be different and insulate itself from competitors.
Supporting sub domain is needed because the core subdomains depend on the supporting sub domains.

Categorisation of the sub domain help the business in making the build versus the buy decisions and the business gets the most return on investment by investing in the solutions in the core sub domain.
Typically the business will use its best talent and resources for building the solutions in the core subdomain.

\section{Understanding the Business Context}
To make an objective decision, you will need additional facts or information on the situation.
I.e the context.
The idea is that as an IT team, you will be carrying out knowledge crunching exercises.
To carry out these knowledge crunching exercises you must be aware of the business context.
In order for IT teams to understand the business domain, they must understand the business context.

Lack of understanding of the business context may lead to confusion and misinterpretations and that will lead to misrepresentation of the domain models.

It is important that the IT team understands the business context, without the appropriate understanding of the business context the IT team may not be able to come up with accurate models representing the business domain.


\section{Business Domain Language}
Business teams use business language, whereas the technology teams tend to use technical terms in their communication.
This difference in language between the business teams and the IT teams can lead to linguistic challenges.
The message here is that the same term used in different regions may lead to confusion, that is even more true for the business language used on multiple domains.
If you are using business terms from one domain in another domain then it may lead to confusion and misinterpretations.

Each industry has its own lingo, i.e  a set of terms that only the experts in the industry or profession use.
They all use a set of terms that have meaning only in their professions and within the same industry there may be specialisations.
To understand the domain or to gain knowledge of the domain, one must understand the language used by the domain experts.
Some challenges.
The first challenge is that there are multiple business languages across the enterprise.

The challenge here is that for building complex, IT teams must learn multiple business languages used by the domain experts in the context of different domains or sub domains.
The second challenge is that same term may appear in the context of different business domains.
The challenge here is that the same term across multiple domains may have a different meaning depending on the context and cause confusion amongst the IT teams.
The third challenge here is related to the fact that IT teams have their own lingo......
These are the terms that are commonly used by the IT teams and technology teams to translate the business terms into IT lingo.

When they receive information about the domain or the knowledge from the domain expert in domain terms, they translate it into technology terms.
Communication from the domain expert to the IT expert happens in terms of the domain language, whereas the communication from the IT expert to the domain expert happens in terms of the technology language.

Domain driven design suggests setting up a common language within each business context and this language is used by all stakeholders, including the IT teams.
This language is referred to as the ubiquitous language and it helps in breaking down the domain into multiple parts that are suitable for building microservices.

\section{Strategic Pattern: Ubiquitious Language}
Ubiquitous language is one of the strategic patterns in domain driven design.
The domain driven design suggests setting up a common language within each business context and this common language is referred to as ubiquitous language.
Ubiquitous language can be though of as a dialect that is used by the various teams within an organisation.
A dialect is defined by the vocabulary and ubiquitous language has a clea definition of the context to which the vocabulary or the glossary applies to.
The glossary contains the common terms and acronyms used within the defined context.

Optionally, it may also have example usage for the terms and acronyms and it may also have references or links to the relevant assets.
Can be seen as an enterprise business dictionary with differences.
Ubiquitous language is not created and managed separately, multiple in an organisation.

Business expert speaks in business terms.
Tech expert speaks in terms of tech terms.
There is a misconception that the it is the business expert defining the language.
This ubiquitous language is not imposed by the experts.
It is not a language used in the industry, it can be though of as a team language, or tribal language that develops or evolves over a period of time by way of collaboration between the business and the technology experts.

The team creating the ubiquitous language can use multiple techniques, such as drawing the process flow, diagrams, user stores and event storming.
This lead to the creation of the ubiquitous language for that team.
It is important to consider that this language is not a one time job.
It is a continuous process as the language takes a while to reach the high level of maturity.
There are no special tools for this.
Any tool can be used as long as it will make the ubqiquots language accessible to all team memebers.
Collaboration tools such as confluence and quip are commonly used.
Any tools can be used, so long as it make the language accessible for all team members. Once the team is at a certain maturity level they should use it for verything.

If the team is developing the documentation and they create a new term or they find a new term that then that term shoudl be added to the ubiquitous language.

The ubiquitous language should act as a source of truth for all terms used by the team.
This language should be used in the application code as well as in the testing code.
Teams must use this language in all of their conversations.

What is the point?
Translation between busienss and tech is no longer needed.
Things become more conistent and easier to follow for both the domain expert as well as the IT expert.
An interesting side effect is that it helps in identifying overlapping contexts.
What that mean is that we can use ubiquitous language to break apart a business context into smaller parts.
In domain driven design, these smaller parts or contexts are referred to as the bounded context.

Summary - very useful, should be used in all forms of communication include the code.

\section{Strategic Pattern: Boudned Context}
Business domain models are commonly created by laying out the domain capabilities in the business.
Each represents a functional area.
Each of these capabilities or functional areas need some kind of a customer representation in technical terms.

The technical expert will put together the class definition with multiple attributes and to do that the technical expert will gather the attributes from multiple experts from across these domains.
Although the customer object may have multiple attributes each of these capabilities will need only a few of those attributes to manage the model in the long term.

One of the teams will be assigned the ownership of the common model, and this would lead to a dependency between the teams in other capability or functional areas on the central team that will be managing the model.
The dependency will lead to a loss of agility, conflicts and complexity.

Domain driven design addresses the problems with the common domain model by breaking the domain in to independent parts referred to as the bounded context.
This addresses the inherent complexity in the unified enterprise model or the common models.
Keywords here are bounded and context.

There are certain characteristics that must be met for these bounded capabilities to be referred to as the bounded context.
The first one is that each of these bounded contacts must be represented with its own domain model.
There is no sharing of the domain model.
The domain model is built for the bounded context is only applicable within the boundaries of that bounded context.
Each bounded context has its own ubiquitous language.

Characteristics in detail.
First one is independent domain models.
Each capability has different modelling requirements.
These models are created and managed independently by the technology teams assigned to each of these functional units.

Since these models are independent, teams from assigned to each of these functional units do not need to have knowledge of the models managed by other teams.
Models can evolve independently across the functional units wihin an enterprise.

Another characteristic of the bounded context is that there is a language that holds meaning within a bounded context i.e ubiquitous language.
Terms are only meaningful within a bounded context.

Summary
Bounded contexts can be thought of as a conceptual boundary around the business capabilities.
These bounded contacts have certain characteristics.
Models can be developed in the bounded context, have applicable only within that bounded context.
The language is only relevant in that bounded context.

\section{Discovering the Bounded Contexts in a Domain -This is not a straight forward task. An art not a science.}

Need to partner with the domain experts.
Start by looking at the organisational structure.
Typically they are available as diagrams that depict the various business capabilities or functional areas within the orgnisation.
Next step, identify the business experts in the core domains and partner with them to understand their responsibilities and they key activities they are invovled in.
Go deeper into some of their key activities.
Be on the lookout for clues in the business language used by the domain experts.
If you organisation has invested in well-designed, modular, monolighic applications they can also act as a starting point.
Look at modules in the monolithic applicaiton and create the boundaries for the business contexts realised in those applications.

Overrall idea is to gather the clues from these excercises and then use these to mark the boudnaries for the bounded context to describe each one of these and the sue of these clues.

Practically speaking. Do not think that the boundaries have to be perfect as this can take some time.
Start with some boundary and then none.

Most organisations are good at documenting and maintaining their organisation structure
In a new organisation, a good place to start is to give attention to the business cuntions depicted in the organisation structure.
Business functions can be treated as a starting point for the bounded context.
Just a starting point.
Will need to delve deepening into each of these business capabilities to refine these boundaries further.

As a next step, may look at the responsibility of each of the business experts and keep in mind that these business experts may be responsible for multiple functions.
During information gathering pay attention to the business language that these experts are using.
The key activities of the business are the activities that the business model must carry out to make the business model work.

Going deeper into each of these activities in collaboration with the business experts will help the IT experts to understand the contextual boundaries within the consumer banking downmain.

Need to collaborate with the key business experts to identify the key actives in your organisation and then dig deeper into each of these activities as you are going through.
Check for linguistic clues to help understand the bounded context from the business use cases and the process perspective.

Well designed application may already have these boundaries in place.
Long story short monolithic applications should not be ignored and they may be used as a starting point for creating the bounded contexts in your business domain.

Summary
Leverage available assets like organisation structure and well designed monolithic applications to identify the bounded contexts.
Partner with business experts to understand their key responsibilities and activities.
Need to pay close attention to the language used to help identify the bounded context.

\chapter{Bounded Context Relationships}

\section{Introduction to DDD Integration Patterns}
Bounded contexts are independent, but the bounded contexts are not isolated from other bounded contexts around them.
Models in the bounded context collaborate to fulfill the requirements of a system.
The basic premise behind this is that when you build microservices, they will not fulfill all of the system requirements on their own.
These microservices will need to interact with other microservices.
These relationships imply some kind of dependency between the bounded contracts or the microservices.

There are multiple types of relationships between the bounded contexts.
In a symmetric relationship, two bounded contracts depend on each other.
- In this scenario, bounded context A is dependent on bounded context B and bounded context B is dependent on Bounded Context A.
In a assymmetric relationship, one bounded context depeneds on another bounded context B in a one to many relationship. I.e multiple bounded context depend on a single bounded context.

There are multiple relationship patterns, these patterns define the dependency relationship between the bounded contexts.

Note:
Big ball of mud is an anti pattern in software developement. As a designer of micrservices this should be avoided.
Context maps are visual representation of the relationship between the bounded contexts.

\section{Managinc Bounded Context Relationships using Context Maps}
Unmanaged bounded context relationships leads to the big ball of mud. I.e badly structured models that lead to spaghetti code.
- This kind of a model and spaghetti code is typically created by unregulated growth and fixes over a period of time.
- Big ball of mud in the context of domain driven design refers to an anit-pattern. Generally should be avoided.

Bounded contexts cannot stay isolated but the relationships need to be managed.
Otherwise there will be a loss of model integrity, and there will be a loss of a team's ability to operate independently (very bad!)

Challenges:
Consider sceanario with BC-A and BC-B. Each has its own model.
Say there is a dependency between A and B. Now A depends on B and will have a dependency on B's models.
- The impact is that now linguistic boundaries within the bounded context A does not hold.
- There may be confusions in terms of the language used for A's and B's models, in otherwords the BC is no contaminated. This is referred to as loss of model integrity.

Bounded contexts are translated into a one or more microservices.
Dependencies between the bounded context are eventually translated to the dependencies between the micrservices. (consider)
Changes will require some kind of collaboration between the teams owning these microservices APIs, this means that teams will lsoe their abiltiy to operate independently.
- This will lead to loss of agility which is counter to one of the reasons why microservices architecture is adopted.

We know that bounded context dependencies or microservices dependencies cannot be avoided.
The suggestion is to manage these bounded context relationships using appropriate domain driven design patterns.

Teams must make a conscious effort not to create a big ball of mud.
They must make a conscious effort not to create a big ball of mud, and they must document the relationship between the bounded context using context maps.

Context maps are a visual representation of the systems, bounded contexts and relationships between them.
%TODO insert diagram

Multiple benefits of using context maps.
First one is that it makes it easier for the team members to understand the big picture.
The next is that it helps in understanding the interdependencies between bounded contexts.
The third one iss that is helps the teams gauge the level of collaboration needed with other teams.
The context map also helps in refinement of the bounded context and the models.

Summary
- As a designer of the microservice, you must avoid creating a big ball of mud.
- The idea is that if you create too many dependencies between the bounded context, it will lead to the loss of benefits that you expect to realise form the microservices architecture.
- Next one is that as a microservices designer, you must use well-defined patterns for defining the relationships between your bounded contexts.
- Last but not least, document the relationship between the bounded the bounded context, using context maps.

\section{Symmetric Relationship Patterns}

Three new strategic patterns.
Separate ways, partnership pattern and the shared colonel pattern.
There may be a scenario where the bounded contexts in a system has no relationship with other bounded contexts.
In such a scenario, the bounded contacts are truly independent or autonomous.

Consider the scenario where there are two bounded contexts A and B which have no relationship.
- This means that there is no sharing of models between these two bounded contexts since they are independent.
- Teams can work on these two bounded contexts autonomously.
- In other words, these teams do not have to collaborate or coordinate for any task.
Could argue that there are opportunities to reuse parts of A and B or vice versa but one has to consider the trade off.
- The tradeoff is that if there is reuse, then there will be a loss of autonomy.
- To go a little deeper say there is a model shared by team B then the teams cannot work autonomously.
- Why? because if A has to change the model, then the team for B will need to agree to the changes.
- Regarding the reuse, when there is no relationship between the bounded contexts of A and B then this is referred to \textit{Separate Ways pattern}
- From the realisation perspective, this means that they will independent set of applications or services for each of the bounded contexts.
--- Teams will be able to independently develop applications and services for these two bounded contexts.
--- This means that these two teams can work independently at their own pace to meet the business goals of their respective business unit.

Sometimes you find bounded contexts that have mutual dependency on each other.
This kind of a relationship between the bounded context is referred to as the symmetric relationship or bidirectional dependency.
To depict a symmetric relationship, a solid line is placed between the bounded contexts.
This mutual dependency leads to high level of coupling between the bounded context and this type of relationship is referred to as the partnership pattern in domain driven design.

From the realisation perspective pattern, this translates into services that have mutual dependencies.
What this means is that the services may be developed by different teams,but because of the mutual dependencies between the services, the teams cannot operate independently.
Not only that, each of the teams engaged in this kind of a relationship would need to learn the business models and the ubiquitous language for the bounded context managed by the other team.
What this means is that the teams in this kind of relationship will need to coordinate their changes, deployments and their releases and that will defeat the purpose of adopting microservices architecture.
- How is this problem solved?
- One way to solve this problem is to demarcate the boundaries for the shared models.
- Consider two independent teams A and B.
----- They can create a demarcation around the models that are shared between the two bounded contexts.
----- The idea is to manage these shared models independent of the rest of the bounded context.
----- What this means is that if A needs a change and this change is not part of the shared models then the team assigned to bounded context A can make independent decisions.
----- Similarly if there are changes needed outside of the shared models and bounded context B the team assigned to bounded context B can make those decision independently.
------ At any point, if there is a need for making a change to the shared models, then the two teams will coordinate.

The sharing od models between the bounded context is referred to as the shared kernel pattern.
The important thing to keep in mind for the shared kernel is that overlapping parts of the context represent the shared domain model, the shared concepts and the shared business language between the two bounded contexts.
Typically, the shared kernel is realised by way of shared libraries such as Java Jars, Python packages and Ruby Gems etc........
Teams can independently develop services that use these shared libraries.

It is okay for the teams to use shared kernel and shared libraries so long as the scope of sharing between the bounded context is limited to a small set of models for scenarios involving sharing of too many models.
Between the bounded context, it becomes difficult to maintain the integrity of the boundaries of the bounded contexts and this is the reason for the suggestion to use shared kernel only, if we are talking about a small set of shared concepts between the bounded contexts.

Summary - Strategic patterns

First one is the separate ways pattern in which there is no relationship between the bounded contexts
As a result, the teams working on the two bounded contexts can work truly independently.

The next one is the partnership pattern in which there are interdependencies between the bounded contexts.
As a result, teams must coordinate with each other to make changes to their own bounded contexts.

The third one is the shared kernel in which it is suggested that the boundaries of the shared concepts and models be clearly demarcated and only the changes to these shared models need to be cordinated by the teams.
In other words, if the team is working on changes that are not related to the shared models or concepts, the it can carry out those changes withouth needing input from the other team.

\section{Asymmetric Relationship Patterns}

Two terms, upstream bounded context and downstream bounded context.
Three patterns, customer supplier pattern, conformist pattern and the anti-corruption layer pattern.

One bounded context has dependency on another bounded context.
This kind of a relationship is depicted by way of assigning roles to the bounded context.
The bounded context that exposes modesl to the other bounded context is referred to be in the upstream role an the bounded context that is dependent on the other bounded context is referred to be the downstream bounded context.
This depicts a relationship in which bounded context A has knowledge of models in bounded context B, and since the relationship is asymmetric bounded context B does not have any knowledge of the models in bounded context A.
- An important thing to keep in mind here is that this relationship does not indicate the flow of data or information.
- It depicts the dependencies from the realisation perspective.
--- The upstream bounded context exposes some functionality and models that are consumed by the downstream bounded context.
--- There are two options that the upstream bounded context has.
--- 1) It can expose the functionality and models based on the needs of the downstream bounded context.
--- 2) The second options is that the upstream bounded context exposes certain functionality and models without any consideration to the needs of the downstream bounded context.

These are two separate patterns.
Option 1 - The upstream bounded context fulfils some specific needs of the downstream bounded context and this pattern is referred to as the customer supplier pattern.-
- Can be thought of as the client server pattern where the server creates the interfaces based on the needs of the client.
- From the realisation perspective, the supplier team always conslults with the customer team to ensure that the suppler service fulfils the needs of the customer services.

Option 2 - The upstream bounded context exposes modesl with no regard to downstream bounded context requirements or needs.
-- In this sceanario, the downstream bounded context accepts the models exposes by the upstream bounded context.
-- This type of relationship pattern is referred to as the conformist pattern.
-- In this pattern, the downstream bounded context conforms to the upstream bounded context models.
-- To depict this relationship %%TODO See or create diagram using TikZ
-- BC A is conforming to the models exposed be BC B
----- One important not here is that bouth the bounded contexts use the same model.


Consider a scenario in which the downstream bounded context decides not to conform to the upstream bounded context.
- In other words, the team for bounded context A decides to create their own model instead of adopting the models for bounded context B
--- In that scenario, the models from bounded context will be exposed to the bounded context.
--- A would require some kind of a translation to convert the models from bounded context B to bounded context A.
---- The suggestion is to isolate this translation logic in a separate layer.
---- This layer for the translactoin is referred to as the anti-corruption layer and this pattern is also referred to as the anti-corruption layer pattern.
--- The idea between the anti corruption layer is to protect the bounded context from corruption.
--- See diagram. This kind of relationship is depicted by replacing D with ACL.
------- Depicting a relationship between A and B, wherein each of these bounded contexts have their own model.
------- They have no knowledge of each other's models except that the ACL has the required knowledge of both the models for A and B and carries out the translation from B's model to A's model.

Summary
- The downstream bounded context depends on the upstream bounded context.
-- In the customer supplier pattern, the upstream bounded context adjusts the model to the downstream bounded context.
-- In the conformist pattern, the upstream bounded context does not give any regard to the needs of the downstream bounded context.
------ SO the downstream bounded context conforms to the upstream models in order to protect the downstream bounded context.
-- Teams may decide to use the anti-corruption layer.
----- This anti-corruption layer has the logic for translating the model from the upstream format to the downstream format that way,
----- the downstream bounded context has no knowledge of teh upstream model context and hence there is no direct dependency.
-------- All the code related to the dependency is isolated in the ACL

\section{One to Many relationship patterns}
%TODO create diagrams
%TODO consider schema generation like avro, gRPC, REST api doc generation

Two patterns, open host service and the published langauge pattern.
In the one to many relationship upstream bounded contexts referred to as providers offers common services to two or more bounded contexts.
-- THis is referred to as the as the open host service pattern.
-- To depict this common services pattern.
-- There is an open host service provider which offers a common language for integration.
-- This common language is accepted by teams working on the downstream bounded context.
--- This common language is referred to as the published language, and this pattern is referred to as the published language pattern.

Summary:
Open Host Service pattern in which the upstream bounded context provides a set of common services or common capabilities to the downstream bounded context.
Published language pattern which goes hand in hand with the open host service pattern.

The upstream bounded context or the open host service provider exposes the common language for the common services.
This language is managed by the team responsible for the open host service.
The downstream bounded context accepts this publish language

\chapter{Domain Driven Design - Tactical Patterns}

\section{Introduction to DDD Tactical Patterns}

\section{Entity Object - Pattern}

\section{Value Object - Pattern}

\section{Aggregate and factory pattern}

\section{Model Behaviour: Anemic and Rich Models}

\section{Repository Object - Pattern}

\section{Domain Service - Pattern}

\section{Applicatoin Services - Pattern}

\section{Infrastructure Services - Pattern}

\chapter{Event Driven Architecture and Domain Events}
\section{Intro}
Relationships between bounded contexts.
Bounded contexts get translated into microservices and these relationships get translated into interactions between the microservices.
Rest over HTTP APIs are a common synchronous mechanism by which microservices interact.

Microservices also produce different types of events.
These are consumed by other microservices as well as the components within the bounded context where the event was produced.

Event driven architecture is an architecture paradigm promoting the production detection, consumption of, and reaction to events.
Microservices are producers and consumers of events.
As a result, event driven architecture is commonly used for building applications with microservices.
Events are asynchronous in nature and realisation of events based interactions require the use of some messaging technology.
There are multiple messaging technologies available for this purpose. (Kafka / RabbitMQ) %TODO consider where Aeron etc fits into this

\section{Monolithic and Distributed Communication Patterns}
First pattern is the monolithic object communication pattern in which the object calls methods on other objects.
All of this is happening within a common memory space or within a common process.
This is typical of a monolithic application.
Referred to as a monolithic object commnication pattern.

\paragraph{Note}
In distributed applications or systems the components reside in their own process space.
In other words there is no sharing of compute or memory resources between the components.
These components communicate with each other by way of some kind network protocol.
This network communication protocol may be synchronous or asynchronous in nature.
- By Synchronous, the caller statys blocked until it received a response from the other component.
- Examples: HTTP, RPC

- by Asynchronous communication, the caller does not wait for a response
- Examples: Advanced Message Queueing Protocol

These are not mutually exclusive.
Communication may be between two endpoints.
Referred to as 1 to 1 communication, also known as single receiver communication.
Common example is HTTP, wherein the communication is between two endpoints.
With synchronous protocols you wil always have 1 to 1 communication (Reactive :D)

This communication pattern may also be realised by using the asynchronous messaging mechanism.
It will look synchronous but the underlying protocol is asynchronous

In a one to many communication pattern, there are multiple components that are interested in receiving messages from the sender.
This is commonly achieved by way of a pub sub messaging pattern.
- A message is published by a publisher to a topic
- Other components will subscribe to the topic and receive messages.
- Each of these components will carry out a specific task assigned to it.

Common protocols for this kind of communications is REST over HTTP for these microservices.

For messaging there are two types of products. Products that are AMPQ compliant such as ActiveMQ and RabbitMQ.
Then there are products that are non AMPQ compliant such as Kafka, Amazon, SQS, Amazon, SNS. These are only examples.

\paragraph{Consider Adding Reactive Patterns}

\section{Event driven architecture}
Events occur naturally in business scenarios.
Events are an indication that something of significance has happened at a point in time or that something has happened in the past.

There are consumers who are interested in knowing about the events, so they would like to be notified.
When an event occurs, one or more consumers are notified about the event.
On receiving the event, the consumer may carry out processing, and this processing of the event is independent of the producer of the event and other consumers of the event.
An event driven architecture is a software architecture paradigm that promotes the designing of systems as loosely coupled components that act as event producers and event consumers.
Central to the event driven architecture is an event backbone.
This event backon is a infrastructure component.
It is referred to by multiple names, event bus, event broker events, router events and mediator events hub.
- Common terms used for this component.
- Name dependes on the product features and functions and the vendor """marketing""" these products. (Warrants research)
- Important to keep in mind that conceptually they are similar.
- They all provide a way for routing of the events from producers to the consumer.
- Producer of the event inform the event backbone of something of interest happening.
- They do this by way of synchronous mechanism exposed by the events backbone.
- When the events backbone recieves the event, it figures out where that event needs to be routed depending on the consumers that are interested in that event.

The important thing to keep in mind here form the event consumer perspective is that they are not polling for these events. They are notified.
Same as the pub sub messaging pattern.
Commonly used for realising event driven architectures.

Data in the event messages.
- The content of the event message may be the state data or the metadata.
- The consumers receiving the message representing the event will get all the relevant state data and they can carry out the processing using the state data that they will recieve in the event messasge.
- It is also possible to design the event structure such that it contains only the metadata.
- Some may need meta data only others may somehow return to the publisher and retrieve the detailed information.
- You would have to use both the state data and metadata in your event messages.
- There is no hard and fast rule but certain consideration.
- If the message size it too big, then there may be challenges related to latency.
- In this scenario you may consider using only metadata in your messages.
- If the consumers are leading to a lot of chattiness in your application because they are reaching out to the producer for getting the state data, then it will be agood idea to go with the state data in the event message.

\subsubsection{API Versus Event Driven Architecture}
APIs rae directed commands, whereas events are observables.
The central theme in an architecture that depends on APIs is an orchestrator.
Ano orchestrator may be thought of as a centralised component that holds the business logic and the flow decisions.
When the orchestrator needs to do something it invokes an API, waits for the response, then invoke other APIs to carry out the required business processing.

In the case of EDA the orchestrator is replaces with event producer and event consumers.
These event consumers are the observers of the events which are produced by the event producer.

One big difference between these two architectures is that the event producers and event consumers all have business logic and are repsonsible for achieving the desired results from the business process.
The event producer does not make a direct invocation on any component.

Rather, it simply triggers an event, a message that is passed on to all the consumers.
Keep in mind that even producers may also be event consumers and event consumers may also be event producers.

Differences between API and Event Driven Architectures
- In the case of APIs, the caller has a knowledge of the API endpoint, whereas in the case of events the producer doesn't know any consumer.
- APIs are synchronous, meaning that the caller has to wait for the response to come back. The caller is blocked.
- In the case of events, a producer just produces an event and moves on. Not it does not even depend on the availability of the consumers.
- What this means is that it can lead to higher availability in the case the consumer is not available
- The producer moves on and when the consumers comes up it receives the event data.
- APIs are based on the reqeust response paradigm wheres in the case of events the message consists of event data, which can be the state data or the metadata in the case of the API.
- Even with the distributed architecture, there is a relatively high level of coupling between the API caller and the API endpoint, whereas in the case of events, the event producers and the event consumers are highly decoupled and the architecture itself is extensible.
- The reason is that you may add or remove consumers without impacting the consumer in any way.
- Typically with APIs, the business logic is centralised, whereas in the case of events the business logic may be spread across multiple components.
- Each of these components, the producers and the consumers have the autonomy to make business decisions.
- With APIs, it is easy to understand the flow because the business logic is centralised.
- With event driven architecture, it is relatively difficult to follow the business logic.

EDA is preferred for microservices but both APis and events can be used. The decision depends on your use case and your requirements.

\subsubsection{Summary}
Events indicate that something of significance has happened.
Event driven architecture is a software architecture paradigm which is based on events.
By nature, EDA uses asynchronous communication between consumers and producers.
EDA is highly decoupled and extensible and the business logic and the business processes in the case of EDA are decentralized.
That means all of the components in the system have some business logic which may be managed independently of other components in the system.


\section{Domain Events - Pattern}
Events are an integral part of the model defined for the bounded context.
- It is important to capture all the relevant events within a bounded context, as a part of the model and the ubiquitous language for that bounded context.
- These evetns are raised by the model components, when there is some kind of a state change.
- Each of these components can raise events to indicate some kind of state change.
- There may be other sources of events within a micro service.
- There may be application monitoring but this is not emitting events related to the bounded context.
- These are technical events and are not a part of the bounded context.
- Components that are emitting events are referred to as the event sources.
- Event constumers are the consumers of those events and these event consumers may be a part of the same microservice.
- In that case the events emitted by the event source are referred to as the domain events.
- Events commited by the event source may be consumer by other microservices.
- What that means is that an event defined in one bounded context is getting consumed in a different bounded context.
- In such cases, the event is referred to as an integration event.
- Event consumer may also be part of an external services. Basically can be thought of as a legacy service, APIs or any other service not implemented as a microservice in such cases.
- Semantically there is no difference between domain events and integration events.
- Its just the consumer that decided whether the event will be referred to as the domain event or the integration event.

Formal definition of domain event.
- A domain event is a message that informs other parts within the same bounded context that something of significance has happned.
- This is the key part within the same bounded context.
- Now, when a domain event is triggered, it indicated a state change within the bounded context and the consumers of the event revieve the event message and execute some busines logic within the same bounded context.
- Note: The domain event is triggered within a bounded context and it is consumed within that same bounded context.
- The reason why events have become an integral part of the domain driven design is that events occur naturally.
- Important Note: That is all domains have concept of events.
- A quick way to identify events in a domain is to look for statements like when this has happened then do this.
- This part represents the event and this part represents the reaction to the event that is the business logic.
- This reaction is known as a side effect......!!!


Language plays an important role in domain driven design. Important to be very careful when you are naming you events.
Always use past tense as event has already happened.
Best Practices:
- Ubiquitous language so that there is not need of translation between IT teams and Business teams
- Do not add "event" as a suffix to the event name or do not add "operation" as a suffix.

Event handler refers to the implementation of the event consumer logic.
In the case of the domain event, the handler is part of the same microservice codebase as the event producer.
These handlers subscribe to the events  of interest and there may be zero or more handlers per event.
Like the events the handlers must be named appropriately.

Use of ubiquitous language as suggested as a best practice, you can name the handler the same as the event that the handler is handling.

Common misconception about event realisation is that events have to be managed with messaging but that is not true for domain events.
Domain events may be emitted and consumed synchronously, for example by way of direct function calls.
- Note: Domain event producer and the handler are in the same process.
- You can use asynchronous mechanism such as in-memory messaging or even an external message broker.
- State changes and raising of the events need to happen atomically.
- In the case of synchronous calls, its easier to implement such mechanisms, whereas with asynchronous you will need to use the appropriate patterns.

\subsubsection{Summary}
- Two types of events - domain and integration events.
- Domain events are emitted and handled within the same bounded context, whereas integration events are handled outside of the bounded context.
- Domain events may be handled synchronously as well as a asynchronously appropriate.
- Naming conventions should be used for naming events and the event handlers.
- State updates and raising of the event must be done in a unit of work or in a transaction.

\section{Integration Events - Pattern}
- Event consumers are outside the source Bounded Context
- Can be consumed by external services
- An integration event is a message that informs components outside of the source Bounded Context that something of significance has happened
- A integration even does not lead to any state changes in the source Bounded Context

\subsubsection{Domain versus Integration Events}
- Domain
- Within a Bounded Context i.e Microservices
- State changed within a BC
- Direct function calls
- Synchronous calls
- Modelled as part of BC model
- Integration
- Between BC or BC and External Services
- No state change in source BC
- Must be a Network Protocol
- Asynchronous preferred
- Consumer decides

Integration events communication
- Asynchronous is preferred
- To achieve higher levels of decoupling
- Future extensibility i.e add new consumers
- Enables one-to-many

Messaging Technology examples: Kafka, RabbitMQ, ActiveMQ......add others

Relationship - Domain and Integration Events
- Domain event may be published as integration event
- Both events defined as part of the model for the BC
- Semantically the same
- Publishing mechanism is different - or same if external messaging is ued for both event types

Integration Event consumer
- Consumer may leverage anti corruption layer

\subsubsection{Summary}
- Domain events may be published as integration events
- Integration events published asynchronously
- Consumer bounded context may use ACL

\chapter{Event Storming for creating shared knowledge}

Events occur naturally in domains.
What that means is that to understand the domain, you must understand the events consumed in the domain.
Event storming is a collaborative exercise that is carried out by the stakeholders to identify the events, producers and consumers in a given scope.
The objective is to create a shared understanding of the domain.
The outcome of the exercise is a knowledge model for the domain.
Event storming is carried out in the workshop format.
There is a facilitator who works with the stakeholders from different parts of the organisation or different parts of the domain.

This workshop may be carried out in person or online using collaboration tools in one of the lectures.

\section{Introduction to Event Storming}

Knowledge crunching is a way by which teams process the knowledge received from the domain experts into a domain model.

How do receive the knowledge from the domain experts?
- Interviews
- Design thinking (from domain driven design)

Common technique called event storming. (Just examples)

Other ways in which you can receive knowledge from the domain experts in a structured manner.
My focus here is on event storming.
A formal definition of event storming is a collaborative, workshop based technique for creating a shared understanding of complex business domains and processes.
Key to realises that this is creating a shared understanding.

The intent is not to design and model the system but to just create a shared understanding among the stakeholders within the domain, and the stakeholders are the business experts as well as the technology experts.
Event storming may be used for creating this shared understanding from the overall perspective or the big picture perspective as well as it can be used for creating the shared knowledge from a business process perspective.
The technique for this is quite flexible in terms of what it can be used for.
The central theme is business events.

The participants in the workshop identify and understand the business events.
They look for the cause of the business events as well as the effect of those business events.
- Technique was created by Alberto Brandolini in 2012 %popular amongst the practitioners.%
\textbf{Biggest benefit of this technique is that it accelerates the development process for complex applications}
One important think to keep in mind is that the knowledge created by way of event storming is used as an input for creating the models.
In other words, you will not be replacing modelling with event storming as an input for creating your UML diagrams. See book about event storming.

\subsubsection{The workshop}
The most important thing about the event storming workshop is that you must invite the right set of domain experts.
There is a dedicated facilitator who works with the participants.
This dedicated facilitator should have some prior experience with event storming.
The number of participants in the workshop is dedicated by the scope.
If you are carrying out the event storming workshop for understanding the business process then you should expect have between 4 and 8 participants in the workshop.
The duration of the workshop depends on the scope of the domain and the experience of the participants.
It may vary anywhere from a couple of hours to a couple of days.
In-person workshop is preferred over online workshops and the reasons is that event storming involves a lot of interactions when the participants are in the same room.

Recently online workshops have also become commonplace and are becoming more acceptable.
Good tools to carry these out online.

An in-person workshop is conducted in a spacious room with a lot of walking area.
This room must offer enough free space on walls to hang the plot of paper so that the participants have unlimited modelling space.
I.e they will not have to stop throwing their ideas on the plot of paper due to running out of the space for it.
Participants will be using a lot of different colored stickies.
At the end of the workshop, the walls will have plotter paper hanging of the walls and there will be a lot of stickies on it.
The stickies on the plotter paper, are color coded.

For an online workshop, participants join over a video call and use a collaboration platform for carrying out the event Storming activities.

All the participants can make changes to a common virtual board and these changes are visible to other participants in real time.
There are many collaboration platforms that allow the participants to do exactly that.

The expected output form the workshop is the creation of a shared understanding of the business process.
The shared understanding is then used for the modelling of the domain.

The objective is not to design to the system.
The objective is not to be able to answer all the questions.
It is not to produce the domain driven design models.

Event storming is a collaborative process for creating share understanding of the domain or the business process.

Event storming is carried out in a facilitated workshop format and it may conducted in person or online.

\section{Elements of Event Storming}

Read the book by alberto....

Business events are natural in all domains.
They are the starting point of the conversation in an event storming workshop.
An important point to note is that all business events are referred to is that all business events are referred to as the domain events in the context of event storming.
The objective of the event Storming workshop is to understand the causation.
What this means is that the participants discuss the domain events to understand the cause of those events and then they also discuss the effect of those events.

This cause and effect is depicted as teh knowledge of the domain by using the six basic elements.

There are six building blocks or elements which are used for depicting the knowledge or flow in an event storming workshop.
Color coded stickies are used to represent each of the six elements.
There is a suggested standard for the colors of these stickies or the elements, specific colors are not required.

You can decide on a standard for the colors of these stickies or the elements but you don't have to follow it as long as you are consistent through out the workshop.
- A domain actor causes a state change in the domain and this state change is initiated by way of a command invoked by the actor.
- This state change is initiated by way of a command invoked by the actor.
- Command is represented by a blue sticky on the workspace.
- This command leads to the raising of domain events, a domain event is a representation of some fact that has already happened.
- A domain event is represented in the workspace as an orange sticky.
- When the domain event is raised, it may lead to a reaction, and this reaction is carried out by way of component that is referred to as the policy.
- This policy is represented by way of a purple sticky..
-- Since domain events represent something that has happened in the past, they should always be named in past tense.

Important to understand that a command is abstract.
That is , it does not represent an active component within the domain.
It simply represents the intent of an actor that must be carried out by the domain.

Business logic execution is carrier out in the command processes in the context of event storming.
The element that carries out the processing of the command is referred to as the aggregate.

The element that carries out the processing of the command is referred to as the aggregate.
An aggregate is represented by way of a yellow sticky.
Apart from the command, an external system or service can also be a source of an event.

Think of the external service as something outside the domain under consideration.
Such external services are represented by a pink sticky.

An event is directly or indirectly associated within a domain.
A state change represents some kind of change in data within that domain.
This data may be of interest to the stakeholder, so the way it works within event storming is that event has some data which is represented by a read model.
This read model is the response to queries for the domain data.
The read model is used by the user interface that the stakeholders can use.
- This user can be an email
- Doesn't have to be a pane of glass showing the data.
- It can be a dashboard for the executor or it can definitely be a browser based application during the event Storming workshop.
The read model is presented by way of a green sticky.
It is also referred to as the.
It is also referred to as the event data model or query model.
They key point to keep in mind is that event has some data which is of value to the stakeholders and this read model repsents that data.

\subsubsection{Summary}
Central idea is the domain event.
The domain event is caused by a command which is processed by the aggregate domain.
Event may also be caused by a command which is processed by the aggregate domain.
Event may also be caused by a command being processed by an external service.
The effect of the domain event is realised by way of a policy that is triggered by the domain event.
This policy may further invoke commands that may lead to other domain events.
Domain event has some data of value to the stakeholder.
The data of value is represented by way of a read model.
This read model may drive a user interface.

\section{Preparing for the ES workshop}

Common for large organisations to hire outside consultants to carry out the facilitation.
(Author says you don't need them.....)

Existing team members such as project managers and Scrum masters can easily be trained to become event storming workshop facilitators.
Bottom line is anyone can learn to become a facilitator by observing experienced facilitators and by practicing.

Make the assumption here that the facilitator is identified and the participants have been invited.
What does the facilitator have to do next?
Prepare the room for the in-person workshop, or if it is a remote workshop then they need to ensure that all the tools are ready to go.
Second thing they need to do is on the day of the workshop, educate the participant on what is the event storming workshop.

Define the scope of the workshop. Make sure all the participants are on the same page in terms of which business process or processes are in the scope of the worksop.
Then level set the expectation by discussing the expected outcome.
Once these tasks have been completed by the facilitator, its time for the facilitator to dive in.

Details of each task.
To set the stage for an in-person workshop, you need to make sure that the room that you're using is spacious.
Move all tables and chairs out of the way.
Reasons for this is to provide space for the participants to move around and hang the plot of paper on the walls with masking take and then draw a timeline from left to right.
The number of plotter papers that you will hang on the wall will depend on the scope of the exercise.
Don't have to hang the plot of paper all around the room, you can do it as you go along.
Idea is to be prepared to set up the stage for a remote workshop, ensure that all the tools are ready to go at least two days prior to the workshop.
Ensure that all the tools are ready to go at least two days prior to the workshop.
I.e have the video conferencing setup.
Must have the tools for the collaboration setup, create a board and make sure all teh participants are able to connect to the video conference and they are able to use the collaboration tools as well.
--> Avoid addressing technical challenges faced by the participants. This can be a dampener.
---> make sure everything is working from day one before the workshop starts.


May have a group of participants who are already experienced with the event storming, but there is no harm in spending a few minutes reminding everyone as to what is involved in the workshop and as part of this education do not use any technical terms.
Specifically do not talk about domain driven design.
Keep it business focused.
Note, participants are no necessarily technologists.
Discuss, the purpose of colored stickies and the workspace, but you don't have to spend too much time on these aspects as participants will learn as you processed through the workshop.
Something that really helps is put all the colored stickies and what they represent somewhere in the workspace so that it is visible to anyone who has a question about what color to use, which is an extermely common question.

In the beginning of the wrokshop, after the general overview of event storming, it is time for the facilitator to define the workshop, after the general overview of event storming, it is time for the facilitator to define the scope of the workshop.
The scope of the workshop may be a big picture from the domain perspective, or it may be a single business process.
Irrespective of what the scope is.
It is important for all participants in the room to be on the sme page and ensure that everyone stays on track.
Place the high level objective for the workshop in the workspace so that it is visible at all times.

Another thing that is important is that as you will start going through the workshop, it is very much possible that there may be discussions around aspects which are out of scope from the workshop perspective, but they may be valueable from the domain perspective.
As a result, you don't want to lose out those aspects, so create a dedicated space to list out all of these out of scope elements.
You can follow up on these items after the workshop.

Facilitator, before the workshop is set the expectations and this is best done by way of sharing real experienced from the past workshops and if possible, sharing pictures form those workshops.
These expectations should be realistic.

Engage the participants and ask them what their thoughts are on the event storming workshop a swell as on what they expect.
Idea is to get everyone excited so that they become active participants in the workshop and they should all be looking forward to learning and teaching.
Use this part of the workshop for ice breaking activities.
At this time, the facilitator is ready to dive in.
One of the important roles for the facilitator is to make sure that everyone is having fun and is energised because low energy will lead to an outcome which is going to be of bad quality.
Participants must feel engaged.
Participants must be active throughout the workshop, so a facilitator must keep those aspects in mind.

\section{Conducting the ES Workshop}

Facilitators must keep in mind that event storming doesn't require the participants to use all of the elements to create the knowledge model.
It is the facilitators job to help the participants pick up the relevant elements to design the knowledge model.
A lot of flexibility in how the event storming workshop is conducted.

Facilitator may adjust the steps, the flow and the pace as needed.
These adjustments depend on multiple facts such as the facilitators and participants, past experiences, complexity of the domain and granularity of the knowledge model.
Whether it is going to be high level or whether it's going to be detailed.
There may be other factors as well.

General steps.
The first step involved in the workshop prioritises the participants to identify the domain events.
Once the domain events have been identified

as a next step, participants discuss the ordering of the events across the timeline.
In this step, duplicate events are also revealed and removed.

In the third step participants are asked to identify the cause and effects of events.
Here commands, policies and external services get added to the knowledge model.

In the fourth step, the commands are associated with the aggregates.

---------

First step in the knowledge gathering exercise.
The facilitator asks the participants to brainstorm and hang as many events as possible in the workspace.
Initially participants may be hesitant.
This is common so it is suggested that the facilitator be the first one to place an event lol.
At this point, all participants should be encouraged to hang events once all the participants have placed the events that they could come up with.

Exercise moves to the next step.
In this step, the participants discuss when each of the events occur and order the events across the timeline from left to right.

One important tip for the facilitator is that facilitators should always remember that their role is to facilitate and they need to let the participants do the modelling.
Once the participants have ordered the events look for duplicates.

Step number three.
Participants need to think about commands policies and actors to identify the cause and the effect of events.

These concepts are a little tricky compared to the domain events, so the point the facilitator is encouraged to ask questions to help the particpants make some progress.

In step number four, the facilitator asks the participants to think about the business.
This is the logic that responsible for creating the domain events.
At the same time it is important for the facilitator to keep track of time.
Every 30 minutes it is suggested that the facilitator review the progress and adjust the pace and the direction as needed.

Facilitator may ask the participants to focus, put people in flow.
Focus may shitft to the next event for which we don't have the domain logic information.

Post workshop activities carried out by the facilitator.
Facilitator takes pictures of the workspace before taking down all of the poltter pare from the walls.
It will be much more easier for the facilitator to go through the pictures rather than rolling out the long sheets of paper.

At the end of the workshop the facilitator asks the participants for their feedback.
What worked well?
What needs to be changed?

The expectation is that the facilitator will incorporate this feedback in their next workshop.
Within 2 to 3 days.

The facilitator consolidates the knowledge and shares knowledge model with all of the participants.
Facilitator requests the participants to go over the knowledge model to ensure its accuracy.

Facilitator decides on the next steps and ensures that all of the parking lot items are addressed.

%TODO excercise

\chapter{Microservices Data Management Patterns}

\section{Introduction to Microservices Data Persistence}
Microservices can independently make changes to their own database without impacting the other microservices.
Conversion of a monolithic application to microservices requires the designer to not only think about the refactoring of the business logic and the components of the monolithic application,
they also need to think about the refactoring of the database.
Refactoring the database would mean breaking the common database instance to multiple database instances

This breaking of common database instance into multiple database instance is not straightforward.
There are multiple challenges.

Pattern that are covered here
- The shared database pattern
- Separate database pattern
- Strangler pattern

\section{Monolithic Apps - Shared Persistence Storage}
The persistence of data is achieve by way of writing to the file systems or by more commonly writing the data to databases.
There are multiple types of databases available today, but the most commonly used databases are the relational databases and NoSQL databases

Legacy applications typically use RDBMS or relational databses for all types of data and this is because NoSQL databases were not available until the early 2000s.

A typical client server application development pattern used by these legacy applications involved multiple enterprise applications, sharing a common instance of the database,
and the enterprise application would manage the data by way of SQL statements against this shared database.

Buy todays standard this architecture will no be acceptable.

There are good things.
First thing is that it will lead to simplified data management process.
Second is that since the database engine is shared by multiple applications, the cost of the solution will go down.
The third is that a single team of database administrators can manage the database for all applications.


Challenges with the shared database pattern.
The first challenge is that database challenges need to be managed very carefully.

Consider the change of database schema.
Very complicated coordination between multiple applications.
Overall this will lead to high cost of changes.
Will lead to higher risk because making a change to the database may lead to breaking of other applications.
This will lead to longer time to value.

Second challenge is that on may negatively impact all other applications, and this can happen if the application intentionally or unintentionally start to use up a lot resources on the database.
Hard to diagnose since each application will only be looking at their own application logs.

The third challenge is that the shared database acts as a single point of failure.
Failure of the database will lead to the failure of all of the applications.

Could argue that a single point of failure may be removed by way of some kind of availability technology, by those high availability solutions are quite complex and they will lead to higher costs.
Other challenges are that it is complex to carry out capacity planning for the shared database as the teams need to coordinate on forcasting the needs that they have from the database perspective.
Application teams will need to be aware of the structure of the data, so onboarding new developers in the teams will be a challenge.

Shared database is an anti-pattern (Reaaak?) but some enterprises are still using it.

SOA originated as a solution but it was very temporary.

\section{Service Orientated Architecure (SOA)}
Data is exposed by way of CRUD services.
CRUD.........
Hide the details of the structure of the database from the applications........
Apart from providing these low level data operations.
So as services may also be built by encapsulating the business logic to provide high level services.
The services layer is placed between the applications and the database.
These services provide the CRUD and high level business operations.

Applications do not need to use SQL to carry out the data manipulation.
They connect with these services over some kind of network protocols that is decided by the service provider.

The server services layer provided multiple advantages since it hit the structure of the database.

The applications became much more simpler to code and manage.
Led to the reuse of code by way of reusable services and the change to the database will become more manageable with the services layer.
Unfortunately it does not address many of the other shared database challenges, such as single point of failure, uncontrolled use of resources and impact on other applications and capacity estimations.

Common misconception.
A small service is not a microservice.

A set of SOA services are part of the same bounded context, whereas a micro service represents a bounded context.

Summary
- Services insulated the applications from database changes, but SOA services did not address all of the challenges associated with shared databases.

\section{Separate Database Pattern}
Recommended for Greenfield microservices initiative.
Greenfield - New application with no constraints from technical debt perspective
Brownfield - Existing monolithic app to be converted to Microservices architecture

Microservices from the ground up.
Microservices teams assigned the bounded context
No interdependency between teams
Each team decide on their tech stack
Service interactions via defined interfaces
No direct access to data

Separate database pattern
Each microservice team owns and manages their database
Benefits - Simpler change management
Reduced blast radius on database failure
Capacity planning - scaling at DB level becomes simpler
Each team can decide on Database - doesnt have to be a RDBMS

Review
- Separate database pattern is recommended

\section{Brownfield Microservices - Database patterns , options}
Share database pattern is considered an anti-pattern in the context of microservices.
Strangler pattern is used for converting brownfield applications to microservices.

in a brownfield project, a monolithic applications is targeted to be refactored into microservices.
The monolithic application will more that likely be a database instance.
The designer of the microservice will have three options from the database perspective.

They can go with the separate database pattern wherein each microservice will have its own instance of the database, or they can retain the common database and do database refactoring to carryout logical separate of the database.
In the last two options the shared database is retained.

Very commonly seen that legacy applications implement business logic as stored procedures.
The idea here is that the databased has a lot of complexities and breaking the database into multiple databases may not be a straightforward task.

A common strategy that a lot of folks take for converting the brown field applications to microservice sis to simpley keep the database in place and convert the application to microservices.
- This will lead to a set of microservices sharing the database and hence they will suffer the same challenges.
Sharing an instance of the database, the shared database pattern in the context of microserviceS is considered an anti-pattern.
The reason for it is that with the shared database, teams lose their independence and not they are interdependent.

Now any change they they will make will need to be coordinated.
Changes would need increased testing effort and overall this will lead to the slow down of delivery of value and on independent scaling will be possible.
The instance of the database may be the choke point, although a shared database is an anti-pattern from the microservices perspective, it is still okay to use shared database pattern for transition state architecture.

....
Start with a monolithic application
Focus only on the application part of it and keep the database as is.
You arrive at this transition state architecture where all the microservices are using a shared database.
Gradually each of these microservices will be refactored to use their own database instance.
This way the shared database is used only as a transition state, not a target state.

One important point ot note about the shared database pattern for microservices, is that the microservices should not have any SQL statement in the code.
The reason is that having the SQL statement in the code will require more effort for switching the database.

Instead, the microservice designer should consider using the strangler strategy.

A collection of services is created for providing the database access to the microservice.
Each of these microservices depicted here will have their own set of services.
These services are just referred to as the strangler services or just stranglers.
The idea behind the services is that switching off the database will have no impact on the microservices, as all of the changes will be confined to the strangler services.
The microservice teams can decide on their priorities and switch databases at their own pace.
Over a period of time, all of the microservices will have their own instances of the databases.
As a result the target state architecture will be achieved.
The strangler pattern is a generic pattern
Can be used of modernisation of any legacy services.

A big benefit of this approach is that microservice code will be insulated from all backend changes as these changes will be confined to the services layer.

Key points
- The shared database pattern is considered an anti-pattern from the microservices perspective.
- Strangler pattern may be used for transitioning from the shared database implementation of the microservices to separate database implementation of microservices.

\section{Shared Database Pattern}
Two options for considering when building microservices against shared databases.

First one is the database refactoring and the logical database separation.
Although shared database pattern is considered as an anti-pattern in the context of microservices, there may be times when the microservices teams will not have the flexibility to use the separate database pattern.
There may be multiple reasons for it.
- Time constraints, budget constraints, lack of skilled resources (hmmm) and the complexity of the database are some of the most common reasons.
In this scenario teams have to consider the shared database pattern.
When using the shared database, the objective of the microservice designer is to achieve maximum isolation of data within the same database instance such tha teach microservices owns part of the data in the database and each microservice ice has access to only the data it owns.

If possible the microservices designer should use the database features to achieve the highest level of isolation between the microservices own data within the database instances.

\chapter{Microservices DB Performance Management}

\section{Need for more Data Patterns}

\section{Commands Query Separation (CQS)}

\section{Realisation of Commands and Queries}

\section{CQRS - Command Query Responsibiltiy Segragation}

\section{Data Replication between WRITE-READ sides}

\section{Event Sourcing and Event Store consideration}

\chapter{Microservices and Kafka}
%TODO Skip for now.....do hands on.

%    \section{Use of Kafka in Microservices}
%    \section{Kafka Overview}
%    \section{Kafka Concepts}
%    \section{Kafka vs AMQP (Rabbit MQ)}


\chapter{Managing Distributed Transactions with SAGA}
%TODO Consider skipping for now. Do hands on
\section{Distrubuted Transactions with SAGA}
\section{SAGA Pattern for distributed transactions}
\section{SAGA Choreography vs Orchestration}
\section{SAGA Implementation Considerations}

\chapter{Microservices and API}
%TODO Potentiall already done. Consider skipping for now
\section{Microservices - API Realisation}
\section{Introduction to REST API}
\section{REST API Resources and Design Constriaints}
\section{API Management}
\section{Introduction to GraphQL}
\section{GraphQL Schema Definition}