%TODO Do excercises and hands if necessary --- or go do my own

\section{Microservices - API Realisation}

\subsection{API - Application Programming Interface}
API - Application Programming Interface is an interface that defines the interactions between multiple software applications or mixed hardware software intermediaries.
The focus here is on microservices, which can be thought of as independent applications.
Microservices expose APIs for consumption by other microservices.

\paragraph{}
It is common for these APIs to be exposed over HTTP but messaging is the preferred protocol for these interactions between APIs.
These APIs are a separate set of APIs that may be exposed to the external components such as user interfaces or legacy applications.
Some of these consumers may even be outside of the organisation that own the microservice for such interactions.

\paragraph{}
HTTP is commonly used and the reason for that is that messaging would require dependency on a specific messaging technology.
In turn this would make the use of the API very restrictive.
HTTP being an open standard makes the API more available to any type of client that can make HTTP calls.

\paragraph{}
Microservices may realised these APIs in multiple ways.
Designers of microservices commonly use RESTFUL APIs and GraphQL APIs at a high level.
The different between the two is how they define the contract between the client and the server.

\paragraph{}
Both have pros and cons.


\section{Introduction to REST API}

Is your architecture useful? - consider the Richardson maturity model.
Some developers think that they by using HTTP and JSON they are creating something that qualifies as a RESTful architecture.
That may or not be true.
These applications may not be RESTful but they may be considered "like REST" or RESTish

\paragraph{What makes an architecture restful?}
In order for an architecture to be restful it must follow six design rules.
These six rules are referred to as the rest Architecture constraints.

\begin{note}
    Described by Roy Fielding in his Dissertation in 2000.
\end{note}

Six constraints - consider researching if required.
\begin{itemize}
    \item First constraint for REST is client server. This constraint suggests the use of client server design principles for impllementing the rest APIs
    \item Second one is the uniform interface that suggests use of well-defined contracts between the client and the server.
    \item The third one is the statelessness, which suggests that the server should not manage the state of the application.
    \item Fourth one is caching - the server should use HTTP caching headers to cache responses to the requests received from the client.
    \item Fifth one is layering - this suggests that the architecture should be layered and each of these layers should be manageable independently
    \item Last one is code on demand - this suggests that a server can not only send dataa to the client in response to the request but it can also send code that the client can execute
\end{itemize}

\begin{note}
    The final one is optional.......but interesting :D
\end{note}

\subsection{Summary}
To summarise - as long as your implementation is following the first five constraints you architecture will be considered as RESTful.
Recall that Rest APIs are not restricted to the HTTP protocol.
So if your API is using HTTP and it is following rest architectural constraints then it is said to be an HTTP REST API or REST of HTTP.


\section{REST API Resources and Design Constriaints}
All real world objects or resources may be described by way of attributes.
In software systems, these attributes are managed in some kind of persistent storage.
This could be an RDBMS or a NoSQL database.
Certain attributes of the object may change over a period of time.
All state changes are captured in a persistent storage.
What we are saying here is that representational state of the car is managed in the database and multiple instances are uniquely identified by some kind of unique ID.
Each can have different attributes.

Think of a system that can query this database.
The system may ask the database and will respond by sending back the representation state of an object or entity.
This is the foundational concept.

From the source database, this representational state data may be in any format.
This could be name value pairs or it may be in a database record format.
This internal representational state is converted to other formats.
Those are not the only formats it can be converted to.
Representational state may be converted to JPEG, PDF, Excel, excerter.

If we replace the logic with the REST API, then it is a good representation of the restfulAPI from the data formats perspective.
What this tells you is that a REST API is not tied to any specific data format.
In fact the same instance of a RESTFUL API can convert and send back the representation state af a resource in different formats based on the clients needs.

All modern APIs use HTTP as the communication protocol and we call such APIs HTTP Rest APIs.
The reason is because the rest APIs style itself, is not tied to HTTP.
You can build REST APIs with other protocols as well.
REST over HTTP APIs expose an endpoint and this endpoint is used for managing the state of the resources.

\begin{note}
    Keyword here is managing the state.
\end{note}

What that tells you is that you can carry out the CRUD operations on the resources exposed by the REST APIs.

You can create, retrieve, update and delete the resources in order to carry out the CRUD operations.
The client has to use an appropriate http verb.

\subsection{An example}
Consider ACME travel HTTP endpoint.
\begin{itemize}
    \item Client will use this endpoint to perform CRUD operations to create a resource (POST).
    \item GET to retrieve the HTTP resource.
    \item PUT for updating the state of an resource (consider idempotency).
    \item DELETE verb needs to be used for deleting a resource.
\end{itemize}

\subsection{Summary - What makes an API Restful?}
Summary - What makes an API Restful
\begin{itemize}
    \item REST APIs - follow a set of design principles
    \item they follow the REST architectural style
    \item they expose resources one which the rest client can carry out operations.
    \item REST APIs are not tied to any specific technology
    \item REST API does not define any standard for request or response payloads or how the API should be built.
    \item REST APIs can use any communication protocol or any data format.
\end{itemize}

\begin{note}
    Note: Not tied to HTTP and JSON, common misconception.
\end{note}


\section{API Management}
APIs exposed by the microservices are consumed by three different types of consumers.
\begin{itemize}
    \item First type are the private or internal API consumers. These private consumers are part of the same microservices team or are developers of other microservices. The idea is that the private consumers belong to the same organisation as the owners of the APIs
    \item The second type of consumer are the public or external consumers. These are independent developers outside of the organisation.
    \item The third type of consumer is the partner API consumers.
\end{itemize}

\begin{note}
    From the implementation perspective there is not difference between the three types of API.
    The difference is how they are managed.
\end{note}

\subsubsection{Private vs Public.}
Private API consumers could invoke the API more often then a public one.
Another example is that a private consumer could have access to more features, wheres public consumer is restricted.

These aspects of an API are managed outside of the microservices implementation by way of an API management platform.
Can think of an API management platform as a technology that is used to address the common API concerns.
These common concerns are typically the concerns related to the access and authorisation to the APIs logging and analytics quotas.

Microservices expose their APIs by way of these API management platforms.
\begin{itemize}
    \item The API management platform exposes the API by way of a proxy or endpoint.
    \item The consumers of the API invoke the API by way of the proxy endpoint.
    \item They never connect directly to the API exposed by the microservice when the consumer invokes the API.
    \item The API management platform applies the management control and based on the outcome of those controls, the API management platform either allows the invocation oif the API on the microservice or it denies the reqeust for invocation.
\end{itemize}

\subsection{Management control}
Most API management platforms offer a declarative or policy based management features.
What this means is that the developer of the microservice doesn't have to code any of these management controls.
They can simply put together policies for defining these controls.

\paragraph{Example} A policy may be defined for the internal or private consumer to be such that maximum flexibility is provided to the consumer.
So in other words, most of their calls will go through the public domain developers, the policy may be extremely restructured to partner APIs.
The policy may be such that it defines some kind of a SLA.

\subsection{How are these policies defined?}
How are these policies defined?
These policy definition mechanism is totally dependent on the API management product.
JSON is commonly used for defining these policies.

For further research look at Apigee, Mulesoft etc.
To understand these JSON policy documents. Also check out cloud equivalents.
The reccomended approach is to use an API management solution.
There are multiple benefits, but one of the biggest is:
\begin{itemize}
    \item The team can focus on the domain or the business logic, rather than spending time on common concerns such as security logging etc.
    \item As a result microservice code is cleaner.
\end{itemize}

Last but not least, since the consumers of the API do not connect directly to the microservice change management becomes easier.
What that means is that the microservices development team can make the changes to the API and adjust the proxy on the API management platform to insulate the end consumer from those changes.

\subsection{Key Points}
\begin{itemize}
    \item There are three types of APIs depending on the type of consumers
    \item The private API is consumed by the consumers within the same organisation.
    \item Public APIs are consumed by consumers that are outside the organisation and are in the public domain
    \item Partner APIs are used by the partners of the organisation
    \item Microservice expose APIs and the consumers do not connect directly to these APIs, but they connect by way of an API management platform that provides a policy based mechanism for addressing common concersn related to APIs.
    \item Since these common concerns are address by the API management platform, microservices implement only the business logic for the APIs.
\end{itemize}

%TODO - example or create my own, design or create my own


\section{Introduction to GraphQL}

GraphQL is a query language for APIs that is not tied to any specific database or technology or network protocol.
GraphQL is a specification for query language.
At the time, the term GraphQL is also used for referring to a component that implements the GraphQL specifications.
A GraphQL server exposes the GraphQL API endpoint that is used by the GraphQL clients to invoke GraphQL operations.

\begin{note}
    History: Developed by Facebook/Meta for use in mobile applications in 2012 and then became open source in 2015.
\end{note}

The are many small to large organisations that have adopted GraphQL as a standard for their APIs

\subsection{REST vs GraphQL}
REST API exposes the API interface to the client by way of contract.
The contract defines the schema for the request payload that the client sends to the server and it also defines the schema for the response payload that the server sends to the client.
The structure of the response and response schemas is fixed and the client receives all of the data in the response payload, \textit{whether it needs it or not}.
If you think about the REST API server as a data source then it is like executing SELECT * from the table.
As the client has no choice in terms of what it needs in the response schema.
This issue, where the REST API client is fetching more data then it needs is referred to as the \textit{over fetching issue}.

\subsection{GraphQL contract}
GraphQL contract is in the form of a GraphQL schema that defines the operations that are supported by the GraphQL server.
These operations can be query operations, which are equivalent to the retrieves, and the operation can be type mutations which are for updating, creating or deleting the data manged on the GraphQL server.

The GraphQL schema can also have type definitions.
Clients can invoke the queries and tell the server what it needs in the response payload.
Now the client has control over the response.
This is like calling the SELECT with field names etc.
\begin{note}
    This way the client is able to get only what it needs and not have to be concerned with over fetching issues.
\end{note}

\subsection{API granularity}
Generally REST APIs are built as highly granular services and this is done to meet the needs of multiple types of clients.
This leads to an issue.
Under fetching, which results in more network calls from a microservice.
\begin{note}
    This leads to latency and a performance hit.
\end{note}

If this was to be replaced with a GraphQL, the api the provider will put together the GraphQL specification which will be used by the web developer to invoke the GraphQL queries against the API endpoint.
In the query, the client side will specify the fields that it would like to receive as part of the response.
Server will process the query and respond back with the requested fields in the response.
With this setup, with a single call the client is able to retrieve the required data.
Hence both the under fetching and the over fetching issues are addressed by graphQL.

A graphQL server is implemented as a layer to manage all the client interactions.
it sits in front of the application tier.
This layer implements the GraphQl specification and is responsible for managing the client interaction and an invocation of the API.

This layer interacts with the components in the application tier.
The developer of the GraphQL API needs to put together the GraphQl specifications which are used by the GraphQL server layer.

\begin{note}
    There is no standard implementation of GraphQL.
\end{note}

There are multiple frameworks available for different languages.
Each of these frameworks have a different requirement from the application perspective.
Most frameworks require the developers to create GraphQL components that get wired to the GraphQL server, \textit{so the components that the developer needs to put together depend on the framework}.

\subsubsection{GraphQL operation flow.}
In a typical implementation of the GraphQL server client invokes the operation on the endpoint exposed by the GraphQL server.
The GraphQL server on receiving this invocation validates the request against schema definition.
If everything is good, then it requests the application to create an instance of a component provides the implementation for the operation.
This component is also referred to as the query resolver.
The data fetcher component then interacts with the data sources, which can be a database or it can be other components.
The idea is that the data fetcher retrieves the data from on or more sources.
After receiving the data from the source.
The data fetcher then creates one or more instances of the resolver.
These resolvers are then returned back to the GraphQL server layer.
The GraphQL server layer invokes the functions on these resolvers to get the data for the fields that need to be passed in the response.

The graphQL server implementation is available in multiple languages.
\begin{note}
    Link for further research: \href{https://graphql.org/code/}{https://graphql.org/code/}
\end{note}

\subsubsection{GraphQL Advantages}

\paragraph{Recap}
Already learned that GraphQL addresses the over fetching and under fetching issues faced by the rest API clients.
The graphQL API client is in full control of the responses.
Documentation for the GraphQL is provided in the form of schema, so there is not need for separate documentation.
The graphQL server layer provides very descriptive error information to the clients which can be used by the client side which can be used but the client side to understand the exact issue in their requests to the GraphQL server.

\subsubsection{GraphQL Disadvantages}
Biggest one is that there may be performance challenges with complex queries.
Web caching is not as straightforward to implement with GraphQL as it is with the REST APIs
REST APIs are easy to learn compared to GraphQL APIs from the design perspective.
REST APIs are defined in terms of resources and endpoints, whereas the GraphQL APIs are exposed over a single endpoint and the contract is in the form of a schema definition from the control perspective.
The client side has no control on the response with a REST API, whereas the client has full control on the response in the case of graphQL.
REST APIs expose crud operations using HTTP verbs whereas in the case of GraphQL all operations are invoked with either a HTTP GET or POST.
There are three types of GraphQL operations: query, mutation and subscription.
REST API client needs to make multiple network calls to gather the required information, whereas GraphQL API leads to reduced network traffic and that may lead to better performance from use cases.

\begin{note}
    From a use-cases perspective, REST APIs are suited for resource driven applications whereas GraphQL is more suited for data driven applications %(very important.....)
\end{note}

\subsection{Summary}

\begin{itemize}
    \item GraphQL is a specification for APIs
    \item GraphQL addresses the under fetching and the over fetching issues related to the rest APIs.
    \item A GraphQL server implements the GraphQL specification.
    \item A GraphQL developer needs to put together the schema definition for the API and they also need to implement the components needed by the GraphQL server.
    \item The type of components that the developer has to put together depends on the GraphQL server in use.
\end{itemize}


\section{GraphQL Schema Definition}
See this link for details: \href{https://graphql.org/learn}{https://graphql.org/learn}

GraphQL and REST are not mutually exclusive.
Pick the one that makes sense for your use-case.
Evaluate requirements and then decide which one to go for.

The graphQL type system refers to the fact that a GraphQL service defines a set of types which completely describes the set of possible data you can query on the service.
The incoming queries are validated by way of the schema definition language, which is \textit{programming language agnostic}.

\subsection{Schema Definition Language}
Schema definition language is a JSON like language for defining the schema for the GraphQL APIs.
A schema consists of two parts.

\begin{itemize}
    \item The first part are the operations supported by the GraphQL server. These operations can be queries, mutations and subscriptions.
    \item The other part has the types which are the server defined objects and each of these objects have fields of specific types supported by the GraphQL schema.
\end{itemize}

In the context of schema definition, language operations are referred to as the \textit{route types}.

\subsubsection{Route Types}
The route type query is used by the client for retrieval of objects defined on the server in the schema definition language.
The route type query lists out all of the named queries.

Each query is defined with a list of arguments.
These arguments are the query criteria.

A graphQL server may allow the client to modify the state of objects maintained on the server and it does this by defining the route types mutation.

\subsubsection{Route Type Mutation}
The route type mutation is similar to the route type query in the sense that there are named mutations in the specification and these named mutations also take an argument and return objects like named queries.
- The last route type is the subscription route type, which is different from the query and mutation in the sense that subscription operation is not initiated by the client.
- The client subscribes to the events on the server and the server pushes the data to the client in response to the events.
- Types are used for defining the structure of the domain objects.
- The scalar types are the standard types defined in the schema definition.
- Language integer, float, string and boolean are foundational scalar types.
- ID is a special type which is not part of the business domain data but is primarily used for managing the caching of the query data.

The GraphQL service defines the complex types by combining them with the standard scalar types.
This no different from the way you define objects in any object orientated programming language.
Language fields may be thought of as attributes in an object.
These attributes have a type which may be a scalar or complex type.

% TODO include an example

The provider type is defined separately in the schema definition by the server.
What this means is that complex types maybe nested and contain other complex types.

\begin{note}
    Key point: Deep nesting of object definitions can impact the performance of the server. %(Lenses)
    This is because deeply nested complex types would require hierarchical resolver implementations and that will in turn also lead to the complexity of implementing the GraphQL server.
\end{note}

\subsubsection{Things that you need to keep in mind when designing types}

These are certain things that you need to keep in mind when designing your types.

Client query execution on GraphQL server.
The first thing the client needs to do is prepare the request payload.
This request payload is a JSON like document.
The structure of this document is defined by GraphQL and the client has to comply with it.
The first thing you see here is the route type which is set to query.
This could be mutations or this could be subscription as well.
Then there is a named query.

The products query is defined in the schema definition to take multiple optional arguments since for the products all of the arguments are optional.
The client may specify zero or more argument values.
These arguments act as the criteria for the query.

\subsubsection{What makes GraphQL different from a restAPI query?}
The client can specify the fields that it desires to receive from the server in the response.

\begin{note}
    This is a key point of GraphQL. \textit{This cannot be done in REST APIs}.
\end{note}

\subsubsection{Example flow}
Example flow
GraphQL server will first validate the reqeust.
The server will delegate the reqeust processing to the microservices components.
The microservice will the create the resolver instances and pass those back to the GraphQL server
The graphQL server in turn will create the response payload based on the reqeust from the client and the reqeust from the client.

GraphQL ecosystem has evolved (check this)
Tools exist to assist with GraphQL development.
Example graphQL playground.

\subsubsection{Summary and Key Points}
Summary:

\begin{itemize}
    \item Think of the schema for your graphQLs APIs.
    \item Think of a schema definition as a shared language.
    \item Don't forget the ubiquitous language for the domain.
    \item Make sure that you schema definitions are mapping to the terms in the ubiquitous language
    \item Take an evolutionary approach to create the API
    \item Don't try to do everything at the same time
\end{itemize}

\begin{note}
    There idea here, is to publish version on of the API and then look at how the clients or the consumers of the API are using your service and based of that, evolve the schema for your APIs.
\end{note}

\paragraph{Key Points}
\begin{itemize}
    \item Schema definition language is used by the server to define the schema or the contract for the API server.
    \item Uses the schema to validate the incoming request for operations
    \item Server also uses the schema for creating the responses that it sens back to the client.
    \item Client uses the schema to create the reqeust payload and to parse the responses it receives from the server.
\end{itemize}

%TODO Add UML and Example ---- or my own Example and something like Mermaid :D