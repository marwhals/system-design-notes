\section{Introduction to DDD and Patterns}
Domain driven design is an architectural approach that provides principles and patterns to address challenges faced with developing complex domain models.
Term originates from from Eric Evans, Domain Driven Design book.

Domain driven design emphasises on the fact that the IT project's primary focus should be on the business domain and business logic rather than technology.
Promotes the idea of breaking the unified model into smaller, more manageable models and it suggests the use of iterative process for improving the model to solve a domain problem.

Domain driven design offers two types of patterns.

Strategic patters are used for dividing a complex and large business problem into smaller chunks with well defined boundaries.

Tactical patterns are used for translating the conceptual models to software application and service designs.

The strategic pattern applies across multiple bounded contexts, whereas tactical patterns are applicable only within a bounded context.

The idea is that domain driven design approach leads to smaller, independent domain models that can be built can be built as highly decoupled and independent set of microservices.


\section{Business Subdomain Types}
A business domain is composed of multiple subdomains.
The type depends on the value a subdomain generates for the business.
Having an understanding of the type of subdomains is in a position to assist the business in making the build versus buy decisions for the technology solutions.
Businesses need to perform multiple different functions to operate.
These functions are performed in the purview of subdomains.
Different organisations within the same industry may look at their enterprises in a different way.
From the subdomains perspective, one of the most common reasons is that businesses may not operate in all sub domains in that overarching domain or industry.
Sub domains may be further divided into smaller sub domains and can be seen as sub domain granularity, and it depends on the focus of the business.
Each organisation within an industry, depending on their focus may view their enterprise as composed of different subdomains under the purview fo which htey performn their business operations.
Each subdomain has a different level of complexity associated with it.
There are multiple factors that may be contributing toward the complexity of the sub domain.

\subsection{Reasons for complexity}
The most common reason it the complexity of the business rules itself.
Another reasons is the compliance aspect.
If the sub domain is operating in a highly regulared environment, then that will add complexity to the sub domain.
Complex calculations or complex algorithms may require specialised skills or specialised knowledge to understand the sub domain and that adds to the complexity.
Next one is the processes and the handovers required between the sub domain and other sub domains or even external entities; will also contribute towards the complexity of the sub domains.

Dynamic - idea here is that if the sub domain requires changes to processes, rules, structures or any other aspect, then it will be difficult to manage the knowledge and understanding of the business domain as it is changing with the time .
Depending on the industry, there may be other factors that will contribute toward the complexity of the sub domain.

\subsection{Sub-Domain Categories}
- Sub-domains are categorized into three types based on their complexity and business value it adds.
- Generic, core and supporting.

\subsubsection{Generic Subdomain}
- Known solutions exist for such subdomains
Nothing special about these subdomains
Best practices available
No business advantage in re inventing the wheel

\subsubsection{Core Subdomain}
- Each business within a specific industry operated differently within the core sub domains to gain some kind of advantage over their competition.
- The "secret sauce" for the business resides in the core sub domain and the business is always looking to carryout things differently in these core subdomains to get some kind of competitive advantage, depending on the indusitry and the environment.
- These core subdomains may evolve at a very rapid pace or may have a very high level of dynamicity.
- Organisations are looking to gain some kind of competitive edge by or achieve cost savings which translates into value for the business.

\subsubsection{Supporting subdomain}
Supporting subdomains do not provide any direct business advantage but the core sub domains depend on the supporting sub domains.
Well known practices for supporting subdomains, but solutions may not be readily available.
- Even if the solutions are available, those solutions may need to be customised to meet the needs of the core sub domain.
\textit{Typically the supporting sub domain does not have high levels of complexity in terms of business logic}

\subsection{Identifying sub domains}
Start by looking at the business capabilities in that sub domain.
Are there any known solutions available for the sub domain?
- If yes, then that sub domain is likely to be generic.
Otherwise need to check if that sub domain adds any business value.
- Is there an opportunity for the business to differentiate itself from it competitors by doing things differently within this sub domain.
If no then the next check is to see if the core sub domains depend on this sub domain.
- If yes then it is likely to be a supporting sub domain.
- If no then the the it is a generic sub domain where you may need to build a solution.

If the sub domain has the potential of adding some business value, then next check is to see if the business domain has high complexity.
If the business domain does not have a high level of complexity then it is likely to be a supporting sub domain.
Otherwise it is likely to be a core sub domain.
%    TODO - Add chart

\subsection{Why categorise the sub domains?}
Businesses have limited resources and these resources here are referring to the HR as well as the money put aside for the various initiatives across the enterprise.
Categorisation of the sub domains helps in prioritisation of the various initiatives.
Second reason is return on investments, businesses would like to maximise their return on investments.
- As a result, preferences will be given to the initiatives replated to core sub domains which will lead to the maximisation of the return on investments.
Third reason is that categorisation of the sub domain helps the business in making the buy vs build decisions.
If the sub domain is a generic sub domain, then the business would buy a IT solution rather than build it.
Examples SAP, Workday etc.
If the sub domain is supporting sub domain, then the business may decide to build the solution by way of outsourcing.
Or they may buy a generic solution and customised it to meet the needs of their core domains. E.g salesforce etc.

If they sub domain is categorised as core, then the business will use its best teams and best talent to build the solution in this sub domain.
The generic sub domain has readily available solutions that the business can buy.
The core subdomain is the sub domain where the business has the opportunity to be different and insulate itself from competitors.
Supporting sub domain is needed because the core subdomains depend on the supporting sub domains.

Categorisation of the sub domain help the business in making the build versus the buy decisions and the business gets the most return on investment by investing in the solutions in the core sub domain.
Typically the business will use its best talent and resources for building the solutions in the core subdomain.


\section{Understanding the Business Context}
To make an objective decision, you will need additional facts or information on the situation.
I.e the context.
The idea is that as an IT team, you will be carrying out knowledge crunching exercises.
To carry out these knowledge crunching exercises you must be aware of the business context.
In order for IT teams to understand the business domain, they must understand the business context.

Lack of understanding of the business context may lead to confusion and misinterpretations and that will lead to misrepresentation of the domain models.

It is important that the IT team understands the business context, without the appropriate understanding of the business context the IT team may not be able to come up with accurate models representing the business domain.


\section{Business Domain Language}
Business teams use business language, whereas the technology teams tend to use technical terms in their communication.
This difference in language between the business teams and the IT teams can lead to linguistic challenges.
The message here is that the same term used in different regions may lead to confusion, that is even more true for the business language used on multiple domains.
If you are using business terms from one domain in another domain then it may lead to confusion and misinterpretations.

Each industry has its own lingo, i.e a set of terms that only the experts in the industry or profession use.
They all use a set of terms that have meaning only in their professions and within the same industry there may be specialisations.
To understand the domain or to gain knowledge of the domain, one must understand the language used by the domain experts.
Some challenges.
The first challenge is that there are multiple business languages across the enterprise.

The challenge here is that for building complex, IT teams must learn multiple business languages used by the domain experts in the context of different domains or sub domains.
The second challenge is that same term may appear in the context of different business domains.
The challenge here is that the same term across multiple domains may have a different meaning depending on the context and cause confusion amongst the IT teams.
The third challenge here is related to the fact that IT teams have their own lingo......
These are the terms that are commonly used by the IT teams and technology teams to translate the business terms into IT lingo.

When they receive information about the domain or the knowledge from the domain expert in domain terms, they translate it into technology terms.
Communication from the domain expert to the IT expert happens in terms of the domain language, whereas the communication from the IT expert to the domain expert happens in terms of the technology language.

Domain driven design suggests setting up a common language within each business context and this language is used by all stakeholders, including the IT teams.
This language is referred to as the ubiquitous language and it helps in breaking down the domain into multiple parts that are suitable for building microservices.


\section{Strategic Pattern: Ubiquitious Language}
Ubiquitous language is one of the strategic patterns in domain driven design.
The domain driven design suggests setting up a common language within each business context and this common language is referred to as ubiquitous language.
Ubiquitous language can be though of as a dialect that is used by the various teams within an organisation.
A dialect is defined by the vocabulary and ubiquitous language has a clea definition of the context to which the vocabulary or the glossary applies to.
The glossary contains the common terms and acronyms used within the defined context.

Optionally, it may also have example usage for the terms and acronyms and it may also have references or links to the relevant assets.
Can be seen as an enterprise business dictionary with differences.
Ubiquitous language is not created and managed separately, multiple in an organisation.

Business expert speaks in business terms.
Tech expert speaks in terms of tech terms.
There is a misconception that the it is the business expert defining the language.
This ubiquitous language is not imposed by the experts.
It is not a language used in the industry, it can be though of as a team language, or tribal language that develops or evolves over a period of time by way of collaboration between the business and the technology experts.

The team creating the ubiquitous language can use multiple techniques, such as drawing the process flow, diagrams, user stores and event storming.
This lead to the creation of the ubiquitous language for that team.
It is important to consider that this language is not a one time job.
It is a continuous process as the language takes a while to reach the high level of maturity.
There are no special tools for this.
Any tool can be used as long as it will make the ubqiquots language accessible to all team memebers.
Collaboration tools such as confluence and quip are commonly used.
Any tools can be used, so long as it make the language accessible for all team members. Once the team is at a certain maturity level they should use it for verything.

If the team is developing the documentation and they create a new term or they find a new term that then that term shoudl be added to the ubiquitous language.

The ubiquitous language should act as a source of truth for all terms used by the team.
This language should be used in the application code as well as in the testing code.
Teams must use this language in all of their conversations.

What is the point?
Translation between business and tech is no longer needed.
Things become more consistent and easier to follow for both the domain expert as well as the IT expert.
An interesting side effect is that it helps in identifying overlapping contexts.
What that mean is that we can use ubiquitous language to break apart a business context into smaller parts.
In domain driven design, these smaller parts or contexts are referred to as the bounded context.

Summary - very useful, should be used in all forms of communication include the code.


\section{Strategic Pattern: Boudned Context}
Business domain models are commonly created by laying out the domain capabilities in the business.
Each represents a functional area.
Each of these capabilities or functional areas need some kind of a customer representation in technical terms.

The technical expert will put together the class definition with multiple attributes and to do that the technical expert will gather the attributes from multiple experts from across these domains.
Although the customer object may have multiple attributes each of these capabilities will need only a few of those attributes to manage the model in the long term.

One of the teams will be assigned the ownership of the common model, and this would lead to a dependency between the teams in other capability or functional areas on the central team that will be managing the model.
The dependency will lead to a loss of agility, conflicts and complexity.

Domain driven design addresses the problems with the common domain model by breaking the domain in to independent parts referred to as the bounded context.
This addresses the inherent complexity in the unified enterprise model or the common models.
Keywords here are bounded and context.

There are certain characteristics that must be met for these bounded capabilities to be referred to as the bounded context.
The first one is that each of these bounded contacts must be represented with its own domain model.
There is no sharing of the domain model.
The domain model is built for the bounded context is only applicable within the boundaries of that bounded context.
Each bounded context has its own ubiquitous language.

Characteristics in detail.
First one is independent domain models.
Each capability has different modelling requirements.
These models are created and managed independently by the technology teams assigned to each of these functional units.

Since these models are independent, teams from assigned to each of these functional units do not need to have knowledge of the models managed by other teams.
Models can evolve independently across the functional units wihin an enterprise.

Another characteristic of the bounded context is that there is a language that holds meaning within a bounded context i.e ubiquitous language.
Terms are only meaningful within a bounded context.

Summary
Bounded contexts can be thought of as a conceptual boundary around the business capabilities.
These bounded contacts have certain characteristics.
Models can be developed in the bounded context, have applicable only within that bounded context.
The language is only relevant in that bounded context.


\section{Discovering the Bounded Contexts in a Domain -This is not a straight forward task. An art not a science.}

Need to partner with the domain experts.
Start by looking at the organisational structure.
Typically they are available as diagrams that depict the various business capabilities or functional areas within the organisation.
Next step, identify the business experts in the core domains and partner with them to understand their responsibilities and they key activities they are involved in.
Go deeper into some of their key activities.
Be on the lookout for clues in the business language used by the domain experts.
If you organisation has invested in well-designed, modular, monolithic applications they can also act as a starting point.
Look at modules in the monolithic applicaiton and create the boundaries for the business contexts realised in those applications.

Overrall idea is to gather the clues from these exercises and then use these to mark the boudnaries for the bounded context to describe each one of these and the sue of these clues.

Practically speaking. Do not think that the boundaries have to be perfect as this can take some time.
Start with some boundary and then none.

Most organisations are good at documenting and maintaining their organisation structure
In a new organisation, a good place to start is to give attention to the business cuntions depicted in the organisation structure.
Business functions can be treated as a starting point for the bounded context.
Just a starting point.
Will need to delve deepening into each of these business capabilities to refine these boundaries further.

As a next step, may look at the responsibility of each of the business experts and keep in mind that these business experts may be responsible for multiple functions.
During information gathering pay attention to the business language that these experts are using.
The key activities of the business are the activities that the business model must carry out to make the business model work.

Going deeper into each of these activities in collaboration with the business experts will help the IT experts to understand the contextual boundaries within the consumer banking downmain.

Need to collaborate with the key business experts to identify the key actives in your organisation and then dig deeper into each of these activities as you are going through.
Check for linguistic clues to help understand the bounded context from the business use cases and the process perspective.

Well designed application may already have these boundaries in place.
Long story short monolithic applications should not be ignored and they may be used as a starting point for creating the bounded contexts in your business domain.

Summary
Leverage available assets like organisation structure and well designed monolithic applications to identify the bounded contexts.
Partner with business experts to understand their key responsibilities and activities.
Need to pay close attention to the language used to help identify the bounded context.


\chapter{Bounded Context Relationships}


\section{Introduction to DDD Integration Patterns}
Bounded contexts are independent, but the bounded contexts are not isolated from other bounded contexts around them.
Models in the bounded context collaborate to fulfill the requirements of a system.
The basic premise behind this is that when you build microservices, they will not fulfill all of the system requirements on their own.
These microservices will need to interact with other microservices.
These relationships imply some kind of dependency between the bounded contracts or the microservices.

There are multiple types of relationships between the bounded contexts.
In a symmetric relationship, two bounded contracts depend on each other.
- In this scenario, bounded context A is dependent on bounded context B and bounded context B is dependent on Bounded Context A.
In a assymmetric relationship, one bounded context depends on another bounded context B in a one to many relationship. I.e multiple bounded context depend on a single bounded context.

There are multiple relationship patterns, these patterns define the dependency relationship between the bounded contexts.

Note:
Big ball of mud is an anti pattern in software development. As a designer of micrservices this should be avoided.
Context maps are visual representation of the relationship between the bounded contexts.


\section{Managinc Bounded Context Relationships using Context Maps}
Unmanaged bounded context relationships leads to the big ball of mud. I.e badly structured models that lead to spaghetti code.
- This kind of a model and spaghetti code is typically created by unregulated growth and fixes over a period of time.
- Big ball of mud in the context of domain driven design refers to an anit-pattern. Generally should be avoided.

Bounded contexts cannot stay isolated but the relationships need to be managed.
Otherwise there will be a loss of model integrity, and there will be a loss of a team's ability to operate independently (very bad!)

Challenges:
Consider sceanario with BC-A and BC-B. Each has its own model.
Say there is a dependency between A and B. Now A depends on B and will have a dependency on B's models.
- The impact is that now linguistic boundaries within the bounded context A does not hold.
- There may be confusions in terms of the language used for A's and B's models, in other words the BC is no contaminated. This is referred to as loss of model integrity.

Bounded contexts are translated into a one or more microservices.
Dependencies between the bounded context are eventually translated to the dependencies between the microservices. (consider)
Changes will require some kind of collaboration between the teams owning these microservices APIs, this means that teams will lose their ability to operate independently.
- This will lead to loss of agility which is counter to one of the reasons why microservices architecture is adopted.

We know that bounded context dependencies or microservices dependencies cannot be avoided.
The suggestion is to manage these bounded context relationships using appropriate domain driven design patterns.

Teams must make a conscious effort not to create a big ball of mud.
They must make a conscious effort not to create a big ball of mud, and they must document the relationship between the bounded context using context maps.

Context maps are a visual representation of the systems, bounded contexts and relationships between them.
%TODO insert diagram

Multiple benefits of using context maps.
First one is that it makes it easier for the team members to understand the big picture.
The next is that it helps in understanding the interdependencies between bounded contexts.
The third one iss that is helps the teams gauge the level of collaboration needed with other teams.
The context map also helps in refinement of the bounded context and the models.

Summary
- As a designer of the microservice, you must avoid creating a big ball of mud.
- The idea is that if you create too many dependencies between the bounded context, it will lead to the loss of benefits that you expect to realise form the microservices architecture.
- Next one is that as a microservices designer, you must use well-defined patterns for defining the relationships between your bounded contexts.
- Last but not least, document the relationship between the bounded the bounded context, using context maps.


\section{Symmetric Relationship Patterns}

Three new strategic patterns.
Separate ways, partnership pattern and the shared colonel pattern.
There may be a scenario where the bounded contexts in a system has no relationship with other bounded contexts.
In such a scenario, the bounded contacts are truly independent or autonomous.

Consider the scenario where there are two bounded contexts A and B which have no relationship.
- This means that there is no sharing of models between these two bounded contexts since they are independent.
- Teams can work on these two bounded contexts autonomously.
- In other words, these teams do not have to collaborate or coordinate for any task.
Could argue that there are opportunities to reuse parts of A and B or vice versa but one has to consider the trade off.
- The tradeoff is that if there is reuse, then there will be a loss of autonomy.
- To go a little deeper say there is a model shared by team B then the teams cannot work autonomously.
- Why? because if A has to change the model, then the team for B will need to agree to the changes.
- Regarding the reuse, when there is no relationship between the bounded contexts of A and B then this is referred to \textit{Separate Ways pattern}
- From the realisation perspective, this means that they will independent set of applications or services for each of the bounded contexts.
--- Teams will be able to independently develop applications and services for these two bounded contexts.
--- This means that these two teams can work independently at their own pace to meet the business goals of their respective business unit.

Sometimes you find bounded contexts that have mutual dependency on each other.
This kind of a relationship between the bounded context is referred to as the symmetric relationship or bidirectional dependency.
To depict a symmetric relationship, a solid line is placed between the bounded contexts.
This mutual dependency leads to high level of coupling between the bounded context and this type of relationship is referred to as the partnership pattern in domain driven design.

From the realisation perspective pattern, this translates into services that have mutual dependencies.
What this means is that the services may be developed by different teams,but because of the mutual dependencies between the services, the teams cannot operate independently.
Not only that, each of the teams engaged in this kind of a relationship would need to learn the business models and the ubiquitous language for the bounded context managed by the other team.
What this means is that the teams in this kind of relationship will need to coordinate their changes, deployments and their releases and that will defeat the purpose of adopting microservices architecture.
- How is this problem solved?
- One way to solve this problem is to demarcate the boundaries for the shared models.
- Consider two independent teams A and B.
----- They can create a demarcation around the models that are shared between the two bounded contexts.
----- The idea is to manage these shared models independent of the rest of the bounded context.
----- What this means is that if A needs a change and this change is not part of the shared models then the team assigned to bounded context A can make independent decisions.
----- Similarly if there are changes needed outside of the shared models and bounded context B the team assigned to bounded context B can make those decision independently.
------ At any point, if there is a need for making a change to the shared models, then the two teams will coordinate.

The sharing od models between the bounded context is referred to as the shared kernel pattern.
The important thing to keep in mind for the shared kernel is that overlapping parts of the context represent the shared domain model, the shared concepts and the shared business language between the two bounded contexts.
Typically, the shared kernel is realised by way of shared libraries such as Java Jars, Python packages and Ruby Gems etc........
Teams can independently develop services that use these shared libraries.

It is okay for the teams to use shared kernel and shared libraries so long as the scope of sharing between the bounded context is limited to a small set of models for scenarios involving sharing of too many models.
Between the bounded context, it becomes difficult to maintain the integrity of the boundaries of the bounded contexts and this is the reason for the suggestion to use shared kernel only, if we are talking about a small set of shared concepts between the bounded contexts.

Summary - Strategic patterns

First one is the separate ways pattern in which there is no relationship between the bounded contexts
As a result, the teams working on the two bounded contexts can work truly independently.

The next one is the partnership pattern in which there are interdependencies between the bounded contexts.
As a result, teams must coordinate with each other to make changes to their own bounded contexts.

The third one is the shared kernel in which it is suggested that the boundaries of the shared concepts and models be clearly demarcated and only the changes to these shared models need to be coordinated by the teams.
In other words, if the team is working on changes that are not related to the shared models or concepts, the it can carry out those changes without needing input from the other team.


\section{Asymmetric Relationship Patterns}

Two terms, upstream bounded context and downstream bounded context.
Three patterns, customer supplier pattern, conformist pattern and the anti-corruption layer pattern.

One bounded context has dependency on another bounded context.
This kind of a relationship is depicted by way of assigning roles to the bounded context.
The bounded context that exposes modesl to the other bounded context is referred to be in the upstream role an the bounded context that is dependent on the other bounded context is referred to be the downstream bounded context.
This depicts a relationship in which bounded context A has knowledge of models in bounded context B, and since the relationship is asymmetric bounded context B does not have any knowledge of the models in bounded context A.
- An important thing to keep in mind here is that this relationship does not indicate the flow of data or information.
- It depicts the dependencies from the realisation perspective.
--- The upstream bounded context exposes some functionality and models that are consumed by the downstream bounded context.
--- There are two options that the upstream bounded context has.
--- 1) It can expose the functionality and models based on the needs of the downstream bounded context.
--- 2) The second options is that the upstream bounded context exposes certain functionality and models without any consideration to the needs of the downstream bounded context.

These are two separate patterns.
Option 1 - The upstream bounded context fulfils some specific needs of the downstream bounded context and this pattern is referred to as the customer supplier pattern.-
- Can be thought of as the client server pattern where the server creates the interfaces based on the needs of the client.
- From the realisation perspective, the supplier team always consults with the customer team to ensure that the suppler service fulfils the needs of the customer services.

Option 2 - The upstream bounded context exposes model with no regard to downstream bounded context requirements or needs.
-- In this sceanario, the downstream bounded context accepts the models exposes by the upstream bounded context.
-- This type of relationship pattern is referred to as the conformist pattern.
-- In this pattern, the downstream bounded context conforms to the upstream bounded context models.
-- To depict this relationship %%TODO See or create diagram using TikZ
-- BC A is conforming to the models exposed be BC B
----- One important not here is that both the bounded contexts use the same model.


Consider a scenario in which the downstream bounded context decides not to conform to the upstream bounded context.
- In other words, the team for bounded context A decides to create their own model instead of adopting the models for bounded context B
--- In that scenario, the models from bounded context will be exposed to the bounded context.
--- A would require some kind of a translation to convert the models from bounded context B to bounded context A.
---- The suggestion is to isolate this translation logic in a separate layer.
---- This layer for the translactoin is referred to as the anti-corruption layer and this pattern is also referred to as the anti-corruption layer pattern.
--- The idea between the anti corruption layer is to protect the bounded context from corruption.
--- See diagram. This kind of relationship is depicted by replacing D with ACL.
------- Depicting a relationship between A and B, wherein each of these bounded contexts have their own model.
------- They have no knowledge of each other's models except that the ACL has the required knowledge of both the models for A and B and carries out the translation from B's model to A's model.

Summary
- The downstream bounded context depends on the upstream bounded context.
-- In the customer supplier pattern, the upstream bounded context adjusts the model to the downstream bounded context.
-- In the conformist pattern, the upstream bounded context does not give any regard to the needs of the downstream bounded context.
------ SO the downstream bounded context conforms to the upstream models in order to protect the downstream bounded context.
-- Teams may decide to use the anti-corruption layer.
----- This anti-corruption layer has the logic for translating the model from the upstream format to the downstream format that way,
----- the downstream bounded context has no knowledge of teh upstream model context and hence there is no direct dependency.
-------- All the code related to the dependency is isolated in the ACL


\section{One to Many relationship patterns}
%TODO create application_system_design.diagrams
%TODO consider schema generation like avro, gRPC, REST api doc generation

Two patterns, open host service and the published langauge pattern.
In the one to many relationship upstream bounded contexts referred to as providers offers common services to two or more bounded contexts.
-- THis is referred to as the as the open host service pattern.
-- To depict this common services pattern.
-- There is an open host service provider which offers a common language for integration.
-- This common language is accepted by teams working on the downstream bounded context.
--- This common language is referred to as the published language, and this pattern is referred to as the published language pattern.

Summary:
Open Host Service pattern in which the upstream bounded context provides a set of common services or common capabilities to the downstream bounded context.
Published language pattern which goes hand in hand with the open host service pattern.

The upstream bounded context or the open host service provider exposes the common language for the common services.
This language is managed by the team responsible for the open host service.
The downstream bounded context accepts this publish language

